<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
   "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Polygon Mesh Processing Library: Tutorial</title>
<link rel="shortcut icon" type="image/x-icon" href="favicon.ico" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/site.webmanifest">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#0066bb">
<meta name="msapplication-TileColor" content="#ffffff">
<meta name="theme-color" content="#ffffff">
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
  <!-- Override right arrow icon from navtree.js -->
  <script type="text/javascript">
  var arrowRight = '&#9655;';
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
<script data-goatcounter="https://pmp.goatcounter.com/count"
        async src="//gc.zgo.at/count.js"></script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><a href="https://www.pmp-library.org"><img height=50 alt="Logo" src="pmp-logo.svg"/></a></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Polygon Mesh Processing Library
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('tutorial.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Tutorial </div></div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#autotoc_md0">Getting Started</a></li>
<li class="level1"><a href="#autotoc_md1">Basic Concepts</a></li>
<li class="level1"><a href="#autotoc_md2">Adding Elements</a></li>
<li class="level1"><a href="#autotoc_md3">Iterators and Circulators</a></li>
<li class="level1"><a href="#autotoc_md4">Dynamic Properties</a></li>
<li class="level1"><a href="#autotoc_md5">Connectivity Queries</a></li>
<li class="level1"><a href="#autotoc_md6">Topological Operations</a></li>
<li class="level1"><a href="#autotoc_md7">File I/O</a></li>
</ul>
</div>
<div class="textblock"><p><a class="anchor" id="md__home_runner_work_pmp_library_pmp_library_docs_tutorial"></a></p>
<p>Welcome to the PMP library tutorial!</p>
<p>This tutorial will walk you through your first steps using PMP. After completion, you should be able to build your own mesh processing applications and use PMP for basic mesh processing tasks.</p>
<p>Note that this tutorial is <em>not</em> a comprehensive introduction to mesh processing. If that's what you are looking for, we highly recommend the textbook of Botsch et al. <a class="el" href="citelist.html#CITEREF_botsch_2010_polygon">[3]</a>.</p>
<p>By the way: This is a living document that's built from the latest version of our sources. If you spot any errors, inaccuracies, or typos, please don't hesitate to report them using our <a href="https://github.com/pmp-library/pmp-library/issues">issue tracker</a>. Your feedback and suggestions are welcome!</p>
<h1><a class="anchor" id="autotoc_md0"></a>
Getting Started</h1>
<p>Let's begin by getting the PMP library source code and building the library and its example applications. In the following, I'm assuming you are using a Unix-like operating system such as Linux or macOS. If you are on Windows the steps are the same but the exact commands might be slightly different.</p>
<p>First, clone the repository using git:</p>
<div class="fragment"><div class="line">git clone https://github.com/pmp-library/pmp-library.git</div>
</div><!-- fragment --><p>The next step is to configure the build system using <a href="https://www.cmake.org">CMake</a>. Create a separate build directory for all the files you'll generate:</p>
<div class="fragment"><div class="line">cd pmp-library &amp;&amp; mkdir build &amp;&amp; cd build</div>
</div><!-- fragment --><p>Now run CMake to generate the build files:</p>
<div class="fragment"><div class="line">cmake ..</div>
</div><!-- fragment --><p>This should work out-of-the-box as long as you have recent compiler and standard build tools installed. In case of doubt, see the detailed <a class="el" href="installation.html">Installation</a> instructions.</p>
<p>By default, CMake will generate <code>Makefiles</code> on Linux and macOS. You can now build the library using</p>
<div class="fragment"><div class="line">make -j</div>
</div><!-- fragment --><p>After watching a few pages of compiler output passing by, you should see something like this:</p>
<div class="fragment"><div class="line">[ 98%] Built target subdivision</div>
<div class="line">[100%] Linking CXX executable ../mpview</div>
<div class="line">[100%] Built target mpview</div>
</div><!-- fragment --><p>Congratulations! You successfully built PMP!</p>
<p>We include a number of example applications that you can to try out. The <code>mpview</code> application provides a simple graphical interface for many of our algorithms. You can give it a try and see what you can do with the famous <a href="https://en.wikipedia.org/wiki/Stanford_bunny">Stanford bunny</a>:</p>
<div class="fragment"><div class="line">./mpview ../data/off/bunny.off</div>
</div><!-- fragment --><p>You should see a window like this:</p>
<div class="image">
<img src="mpview.webp" alt=""/>
<div class="caption">
MeshProcessingViewer showing the Stanford bunny.</div></div>
    <p>If you're having trouble with one of the steps, please read the detailed <a class="el" href="installation.html">Installation</a> instructions carefully. You can also head over to our <a href="https://github.com/pmp-library/pmp-library/discussions">discussions</a> forum and ask for help.</p>
<h1><a class="anchor" id="autotoc_md1"></a>
Basic Concepts</h1>
<p>Polygon meshes are a fundamental data structure for representing 3D surfaces in computer graphics and geometry processing. A mesh is composed of vertices, edges, and faces:</p>
<ul>
<li><b>Vertices</b> are the individual points defining the shape of the object. Each vertex typically has 3D coordinates \((x,y,z)\) associated with it. In many applications additional properties such as colors or texture coordinates are stored for each vertex.</li>
<li><b>Edges</b> are the line segments connecting two vertices. They define the boundary of each face. In a manifold surface mesh, all edges are connected to exactly two faces. In PMP, all meshes are manifold.</li>
<li><b>Faces</b> are the polygonal shapes that make up the visible surface of the object. Each face has at least three vertices. Triangles and quads (4 vertices) are the most frequently used faces. PMP supports meshes with general polygonal faces.</li>
</ul>
<p>We also call those mesh <em>elements</em>.</p>
<div class="image">
<object type="image/svg+xml" data="elements.svg" style="pointer-events: none;"></object>
<div class="caption">
Mesh elements.</div></div>
    <p>In order to access and manipulate the mesh, you also need incidence relationships between those elements. The central class for storing and manipulating all that data is <a class="el" href="classpmp_1_1_surface_mesh.html" title="A class for representing polygon surface meshes.">pmp::SurfaceMesh</a>. It stores connectivity information based on halfedges, i.e., pairs of directed edges with opposing direction. To be more precise:</p>
<ul>
<li>Each vertex stores an outgoing halfedge.</li>
<li>Each face stores an incident halfedge.</li>
<li>Each halfedge stores its incident face, its target vertex, and its previous and next halfedges within the face.</li>
</ul>
<p>The halfedge connectivity is illustrated in the figure below:</p>
<div class="image">
<object type="image/svg+xml" data="halfedge-connectivity.svg" style="pointer-events: none;"></object>
<div class="caption">
Halfedge connectivity.</div></div>
    <p>In the following, we show the basic usage of <a class="el" href="classpmp_1_1_surface_mesh.html" title="A class for representing polygon surface meshes.">pmp::SurfaceMesh</a> by example.</p>
<h1><a class="anchor" id="autotoc_md2"></a>
Adding Elements</h1>
<p>The basic usage of <a class="el" href="classpmp_1_1_surface_mesh.html" title="A class for representing polygon surface meshes.">pmp::SurfaceMesh</a> is demonstrated in the example below. The program first instantiates a <a class="el" href="classpmp_1_1_surface_mesh.html" title="A class for representing polygon surface meshes.">pmp::SurfaceMesh</a> object as well as four vertex handles. These handles, as well as the handles for the other mesh elements <code>Halfedge</code>, <code>Edge</code> and <code>Face</code> basically indices. Four vertices are added to the mesh, as well as four triangular faces composing a tetrahedron. Finally, the number of vertices, edges, and faces is printed to standard output.</p>
<div class="fragment"><div class="line"><span class="comment">// instantiate a SurfaceMesh object</span></div>
<div class="line">SurfaceMesh mesh;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// add 4 vertices</span></div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> v0 = mesh.add_vertex(Point(0, 0, 0));</div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> v1 = mesh.add_vertex(Point(1, 0, 0));</div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> v2 = mesh.add_vertex(Point(0, 1, 0));</div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> v3 = mesh.add_vertex(Point(0, 0, 1));</div>
<div class="line"> </div>
<div class="line"><span class="comment">// add 4 triangular faces</span></div>
<div class="line">mesh.add_triangle(v0, v1, v3);</div>
<div class="line">mesh.add_triangle(v1, v2, v3);</div>
<div class="line">mesh.add_triangle(v2, v0, v3);</div>
<div class="line">mesh.add_triangle(v0, v2, v1);</div>
<div class="line"> </div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;vertices: &quot;</span> &lt;&lt; mesh.n_vertices() &lt;&lt; std::endl;</div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;edges: &quot;</span> &lt;&lt; mesh.n_edges() &lt;&lt; std::endl;</div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;faces: &quot;</span> &lt;&lt; mesh.n_faces() &lt;&lt; std::endl;</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md3"></a>
Iterators and Circulators</h1>
<p>In order to sequentially access mesh elements <a class="el" href="classpmp_1_1_surface_mesh.html" title="A class for representing polygon surface meshes.">pmp::SurfaceMesh</a> provides iterators for each element type:</p>
<ol type="1">
<li><a class="el" href="classpmp_1_1_surface_mesh_1_1_vertex_iterator.html" title="An iterator class to iterate linearly over all vertices.">pmp::SurfaceMesh::VertexIterator</a></li>
<li><a class="el" href="classpmp_1_1_surface_mesh_1_1_halfedge_iterator.html" title="this class iterates linearly over all halfedges">pmp::SurfaceMesh::HalfedgeIterator</a></li>
<li><a class="el" href="classpmp_1_1_surface_mesh_1_1_edge_iterator.html" title="this class iterates linearly over all edges">pmp::SurfaceMesh::EdgeIterator</a></li>
<li><a class="el" href="classpmp_1_1_surface_mesh_1_1_face_iterator.html" title="this class iterates linearly over all faces">pmp::SurfaceMesh::FaceIterator</a></li>
</ol>
<p>Similar to iterators, <a class="el" href="classpmp_1_1_surface_mesh.html" title="A class for representing polygon surface meshes.">pmp::SurfaceMesh</a> also provides circulators for the ordered enumeration of all incident vertices, halfedges, or faces around a given face or vertex. The example below demonstrates the use of iterators and circulators for computing the mean valence of a mesh.</p>
<div class="fragment"><div class="line"><span class="keywordtype">float</span> mean_valence = 0.0f;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// loop over all vertices</span></div>
<div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span> v : mesh.vertices())</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// sum up vertex valences</span></div>
<div class="line">    mean_valence += mesh.valence(v);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">mean_valence /= mesh.n_vertices();</div>
<div class="line"> </div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;mean valence: &quot;</span> &lt;&lt; mean_valence &lt;&lt; std::endl;</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md4"></a>
Dynamic Properties</h1>
<p>Attaching additional attributes to mesh elements is important for many applications. <a class="el" href="classpmp_1_1_surface_mesh.html" title="A class for representing polygon surface meshes.">pmp::SurfaceMesh</a> supports properties by means of synchronized arrays that can be (de-)allocated dynamically at run-time. Property arrays are also used internally, e.g., to store vertex coordinates. The example program below shows how to access vertex coordinates through the pre-defined point property.</p>
<div class="fragment"><div class="line"><span class="comment">// get pre-defined property storing vertex positions</span></div>
<div class="line"><span class="keyword">auto</span> points = mesh.get_vertex_property&lt;Point&gt;(<span class="stringliteral">&quot;v:point&quot;</span>);</div>
<div class="line"> </div>
<div class="line">Point p(0, 0, 0);</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span> v : mesh.vertices())</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// access point property like an array</span></div>
<div class="line">    p += points[v];</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">p /= mesh.n_vertices();</div>
<div class="line"> </div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;barycenter: &quot;</span> &lt;&lt; p &lt;&lt; std::endl;</div>
</div><!-- fragment --><p>The dynamic (de-)allocation of properties at run-time is managed by a set of four different functions.</p>
<ul>
<li><p class="startli">Add a new property of a specific type for a given element type. Example:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> vertex_weights = mesh.add_vertex_property&lt;Scalar&gt;(<span class="stringliteral">&quot;v:weight&quot;</span>);</div>
</div><!-- fragment --></li>
<li><p class="startli">Get a handle to an existing property. Example:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> points = mesh.get_vertex_property&lt;Point&gt;(<span class="stringliteral">&quot;v:point&quot;</span>);</div>
</div><!-- fragment --></li>
<li><p class="startli">Get or add: Return a handle to an existing property if a property of the same type and name exists. If there is no such property, a new one is allocated and its handle is returned. Example:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> edge_weights = mesh.edge_property&lt;Scalar&gt;(<span class="stringliteral">&quot;e:weight&quot;</span>);</div>
</div><!-- fragment --></li>
<li><p class="startli">Remove a property given its handle:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> face_colors = mesh.face_property&lt;Color&gt;(<span class="stringliteral">&quot;f:color&quot;</span>);</div>
<div class="line">mesh.remove_face_property(face_colors);</div>
</div><!-- fragment --></li>
</ul>
<p>Functions that allocate a new property take an optional default value for the property as a second argument. Example:</p>
<div class="fragment"><div class="line">mesh.face_property&lt;Color&gt;(<span class="stringliteral">&quot;f:color&quot;</span>, Color(1.0, 0.0, 0.0));</div>
</div><!-- fragment --><p>The code excerpt below demonstrates how to allocate, use and remove a custom edge property.</p>
<div class="fragment"><div class="line"><span class="comment">// get pre-defined point property</span></div>
<div class="line"><span class="keyword">auto</span> points = mesh.get_vertex_property&lt;Point&gt;(<span class="stringliteral">&quot;v:point&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// add new property storing a point per edge</span></div>
<div class="line"><span class="keyword">auto</span> edge_points = mesh.add_edge_property&lt;Point&gt;(<span class="stringliteral">&quot;e:point&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// loop over all edges</span></div>
<div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span> e : mesh.edges())</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// compute midpoint</span></div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> p0 = points[mesh.vertex(e, 0)];</div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> p1 = points[mesh.vertex(e, 1)];</div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> midpoint = (p0 + p1 ) * Scalar(0.5);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// access edge property like an array</span></div>
<div class="line">    edge_points[e] = midpoint;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// remove property to free memory</span></div>
<div class="line">mesh.remove_edge_property(edge_points);</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md5"></a>
Connectivity Queries</h1>
<p>Commonly used connectivity queries such as retrieving the next halfedge or the target vertex of an halfedge are illustrated below.</p>
<div class="fragment"><div class="line">Halfedge h;</div>
<div class="line"><span class="keyword">auto</span> h0 = mesh.next_halfedge(h);</div>
<div class="line"><span class="keyword">auto</span> h1 = mesh.prev_halfedge(h);</div>
<div class="line"><span class="keyword">auto</span> h2 = mesh.opposite_halfedge(h);</div>
<div class="line"><span class="keyword">auto</span> f  = mesh.face(h);</div>
<div class="line"><span class="keyword">auto</span> v0 = mesh.from_vertex(h);</div>
<div class="line"><span class="keyword">auto</span> v1 = mesh.to_vertex(h);</div>
</div><!-- fragment --><div class="image">
<object type="image/svg+xml" data="connectivity-queries.svg" style="pointer-events: none;"></object>
<div class="caption">
Connectivity queries</div></div>
    <h1><a class="anchor" id="autotoc_md6"></a>
Topological Operations</h1>
<p><a class="el" href="classpmp_1_1_surface_mesh.html" title="A class for representing polygon surface meshes.">pmp::SurfaceMesh</a> also offers higher-level topological operations, such as performing edge flips, edge splits, face splits, or halfedge collapses. The figure below illustrates some of these operations.</p>
<div class="image">
<img src="topology-changes.png" alt=""/>
<div class="caption">
High-level operations changing the topology.</div></div>
    <p>The corresponding member functions and their syntax is demonstrated in the pseudo-code below.</p>
<div class="fragment"><div class="line">Vertex   v;</div>
<div class="line">Edge     e;</div>
<div class="line">Halfedge h;</div>
<div class="line">Face     f;</div>
<div class="line"> </div>
<div class="line">mesh.split(f, v);</div>
<div class="line">mesh.split(e, v);</div>
<div class="line">mesh.flip(e);</div>
<div class="line">mesh.collapse(h);</div>
</div><!-- fragment --><p>When elements are removed from the mesh due to topological changes, the member function <a class="el" href="classpmp_1_1_surface_mesh.html#a18ccfc2210e9d09621859d6f95381aaf" title="remove deleted elements">pmp::SurfaceMesh::garbage_collection()</a> has to be called in order to ensure the consistency of the data structure.</p>
<h1><a class="anchor" id="autotoc_md7"></a>
File I/O</h1>
<p>All I/O operations are handled by the <a class="el" href="group__io.html#ga2bcb6c26485632205f195d41d3aa66d6" title="Read into mesh from file.">pmp::read()</a> and <a class="el" href="group__io.html#gad296359779629df88b6f3c4db874536a" title="Write mesh to file controlled by flags.">pmp::write()</a> functions. They take a mesh, a file path, and optional <a class="el" href="structpmp_1_1_i_o_flags.html" title="Flags to control reading and writing.">pmp::IOFlags</a> as an argument.</p>
<p>We currently support reading and writing several standard file formats: OFF, OBJ, STL. See the reference documentation for the <a class="el" href="group__io.html#ga2bcb6c26485632205f195d41d3aa66d6" title="Read into mesh from file.">pmp::read()</a> and <a class="el" href="group__io.html#gad296359779629df88b6f3c4db874536a" title="Write mesh to file controlled by flags.">pmp::write()</a> functions for details on which format supports reading / writing which type of data.</p>
<p>A simple example reading and writing a mesh is shown below.</p>
<div class="fragment"><div class="line"><span class="comment">// instantiate a SurfaceMesh object</span></div>
<div class="line">SurfaceMesh mesh;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// read a mesh specified as the first command line argument</span></div>
<div class="line"><span class="keywordflow">if</span> (argc &gt; 1)</div>
<div class="line">    read(mesh, argv[1]);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line"><span class="comment">// do something with the mesh</span></div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// write the mesh to the file specified as second argument</span></div>
<div class="line"><span class="keywordflow">if</span> (argc &gt; 2)</div>
<div class="line">    write(mesh, argv[2]);</div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<div id="nav-path" class="navpath">
  <address>
    Copyright © 2011-2025 the Polygon Mesh Processing Library developers.
  </address>
</div>
</body>
</html>