<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
   "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Polygon Mesh Processing Library: SurfaceMesh Class Reference</title>
<link rel="shortcut icon" type="image/x-icon" href="favicon.ico" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/site.webmanifest">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#0066bb">
<meta name="msapplication-TileColor" content="#ffffff">
<meta name="theme-color" content="#ffffff">
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
  <!-- Override right arrow icon from navtree.js -->
  <script type="text/javascript">
  var arrowRight = '&#9655;';
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
<script data-goatcounter="https://pmp.goatcounter.com/count"
        async src="//gc.zgo.at/count.js"></script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><a href="https://www.pmp-library.org"><img height=50 alt="Logo" src="pmp-logo.svg"/></a></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Polygon Mesh Processing Library
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classpmp_1_1_surface_mesh.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="classpmp_1_1_surface_mesh-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">SurfaceMesh Class Reference<div class="ingroups"><a class="el" href="group__core.html">core</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>A class for representing polygon surface meshes.  
 <a href="classpmp_1_1_surface_mesh.html#details">More...</a></p>

<p><code>#include &lt;pmp/surface_mesh.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh_1_1_edge_around_vertex_circulator.html">EdgeAroundVertexCirculator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">this class circulates through all edges incident to a vertex.  <a href="classpmp_1_1_surface_mesh_1_1_edge_around_vertex_circulator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh_1_1_edge_container.html">EdgeContainer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">helper class for iterating through all edges using range-based for-loops.  <a href="classpmp_1_1_surface_mesh_1_1_edge_container.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh_1_1_edge_iterator.html">EdgeIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">this class iterates linearly over all edges  <a href="classpmp_1_1_surface_mesh_1_1_edge_iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh_1_1_face_around_vertex_circulator.html">FaceAroundVertexCirculator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">this class circulates through all incident faces of a vertex.  <a href="classpmp_1_1_surface_mesh_1_1_face_around_vertex_circulator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh_1_1_face_container.html">FaceContainer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">helper class for iterating through all faces using range-based for-loops.  <a href="classpmp_1_1_surface_mesh_1_1_face_container.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh_1_1_face_iterator.html">FaceIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">this class iterates linearly over all faces  <a href="classpmp_1_1_surface_mesh_1_1_face_iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh_1_1_halfedge_around_face_circulator.html">HalfedgeAroundFaceCirculator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">this class circulates through all halfedges of a face.  <a href="classpmp_1_1_surface_mesh_1_1_halfedge_around_face_circulator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh_1_1_halfedge_around_vertex_circulator.html">HalfedgeAroundVertexCirculator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">this class circulates through all outgoing halfedges of a vertex.  <a href="classpmp_1_1_surface_mesh_1_1_halfedge_around_vertex_circulator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh_1_1_halfedge_container.html">HalfedgeContainer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">helper class for iterating through all halfedges using range-based for-loops.  <a href="classpmp_1_1_surface_mesh_1_1_halfedge_container.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh_1_1_halfedge_iterator.html">HalfedgeIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">this class iterates linearly over all halfedges  <a href="classpmp_1_1_surface_mesh_1_1_halfedge_iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh_1_1_vertex_around_face_circulator.html">VertexAroundFaceCirculator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">this class circulates through the vertices of a face.  <a href="classpmp_1_1_surface_mesh_1_1_vertex_around_face_circulator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh_1_1_vertex_around_vertex_circulator.html">VertexAroundVertexCirculator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">this class circulates through all one-ring neighbors of a vertex.  <a href="classpmp_1_1_surface_mesh_1_1_vertex_around_vertex_circulator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh_1_1_vertex_container.html">VertexContainer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">helper class for iterating through all vertices using range-based for-loops.  <a href="classpmp_1_1_surface_mesh_1_1_vertex_container.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh_1_1_vertex_iterator.html">VertexIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An iterator class to iterate linearly over all vertices.  <a href="classpmp_1_1_surface_mesh_1_1_vertex_iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Construction, destruction, assignment</div></td></tr>
<tr class="memitem:a70ef123dcb0954683a2df083e1dafb87"><td class="memItemLeft" align="right" valign="top"><a id="a70ef123dcb0954683a2df083e1dafb87" name="a70ef123dcb0954683a2df083e1dafb87"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SurfaceMesh</b> ()</td></tr>
<tr class="memdesc:a70ef123dcb0954683a2df083e1dafb87"><td class="mdescLeft">&#160;</td><td class="mdescRight">default constructor <br /></td></tr>
<tr class="separator:a70ef123dcb0954683a2df083e1dafb87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80462de7e77a5231315f0e93e69fc1d2"><td class="memItemLeft" align="right" valign="top"><a id="a80462de7e77a5231315f0e93e69fc1d2" name="a80462de7e77a5231315f0e93e69fc1d2"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><b>~SurfaceMesh</b> ()</td></tr>
<tr class="memdesc:a80462de7e77a5231315f0e93e69fc1d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">destructor <br /></td></tr>
<tr class="separator:a80462de7e77a5231315f0e93e69fc1d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56b36b29abcd020e3096c41c7f45ce1c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#a56b36b29abcd020e3096c41c7f45ce1c">SurfaceMesh</a> (const <a class="el" href="classpmp_1_1_surface_mesh.html">SurfaceMesh</a> &amp;rhs)</td></tr>
<tr class="memdesc:a56b36b29abcd020e3096c41c7f45ce1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">copy constructor: copies <code>rhs</code> to <code>*this</code>.  <br /></td></tr>
<tr class="separator:a56b36b29abcd020e3096c41c7f45ce1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77126d22563f53b28ace913cb79e932b"><td class="memItemLeft" align="right" valign="top"><a id="a77126d22563f53b28ace913cb79e932b" name="a77126d22563f53b28ace913cb79e932b"></a>
<a class="el" href="classpmp_1_1_surface_mesh.html">SurfaceMesh</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classpmp_1_1_surface_mesh.html">SurfaceMesh</a> &amp;rhs)</td></tr>
<tr class="memdesc:a77126d22563f53b28ace913cb79e932b"><td class="mdescLeft">&#160;</td><td class="mdescRight">assign <code>rhs</code> to <code>*this</code>. performs a deep copy of all properties. <br /></td></tr>
<tr class="separator:a77126d22563f53b28ace913cb79e932b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3cffd7ff659547ee5372d01f498f882"><td class="memItemLeft" align="right" valign="top"><a id="ac3cffd7ff659547ee5372d01f498f882" name="ac3cffd7ff659547ee5372d01f498f882"></a>
<a class="el" href="classpmp_1_1_surface_mesh.html">SurfaceMesh</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>assign</b> (const <a class="el" href="classpmp_1_1_surface_mesh.html">SurfaceMesh</a> &amp;rhs)</td></tr>
<tr class="memdesc:ac3cffd7ff659547ee5372d01f498f882"><td class="mdescLeft">&#160;</td><td class="mdescRight">assign <code>rhs</code> to <code>*this</code>. does not copy custom properties. <br /></td></tr>
<tr class="separator:ac3cffd7ff659547ee5372d01f498f882"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Add new elements by hand</div></td></tr>
<tr class="memitem:ae4206f3001dd38a564614b481d58bc38"><td class="memItemLeft" align="right" valign="top"><a id="ae4206f3001dd38a564614b481d58bc38" name="ae4206f3001dd38a564614b481d58bc38"></a>
<a class="el" href="classpmp_1_1_vertex.html">Vertex</a>&#160;</td><td class="memItemRight" valign="bottom"><b>add_vertex</b> (const <a class="el" href="group__core.html#ga4fc38b084567aed726be776958bfcc78">Point</a> &amp;p)</td></tr>
<tr class="memdesc:ae4206f3001dd38a564614b481d58bc38"><td class="mdescLeft">&#160;</td><td class="mdescRight">add a new vertex with position <code>p</code> <br /></td></tr>
<tr class="separator:ae4206f3001dd38a564614b481d58bc38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab50547b83aff7a33ae6a534a6d7795ca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmp_1_1_face.html">Face</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#ab50547b83aff7a33ae6a534a6d7795ca">add_face</a> (const std::vector&lt; <a class="el" href="classpmp_1_1_vertex.html">Vertex</a> &gt; &amp;<a class="el" href="classpmp_1_1_surface_mesh.html#a2c155f3e7e2ceabdfb7b5457e891ab9a">vertices</a>)</td></tr>
<tr class="memdesc:ab50547b83aff7a33ae6a534a6d7795ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a new face with vertex list <code>vertices</code>.  <br /></td></tr>
<tr class="separator:ab50547b83aff7a33ae6a534a6d7795ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6a0d31259cf4eacc096bc100bd6dbe5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmp_1_1_face.html">Face</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#ae6a0d31259cf4eacc096bc100bd6dbe5">add_triangle</a> (<a class="el" href="classpmp_1_1_vertex.html">Vertex</a> v0, <a class="el" href="classpmp_1_1_vertex.html">Vertex</a> v1, <a class="el" href="classpmp_1_1_vertex.html">Vertex</a> v2)</td></tr>
<tr class="memdesc:ae6a0d31259cf4eacc096bc100bd6dbe5"><td class="mdescLeft">&#160;</td><td class="mdescRight">add a new triangle connecting vertices <code>v0</code>, <code>v1</code>, <code>v2</code>  <br /></td></tr>
<tr class="separator:ae6a0d31259cf4eacc096bc100bd6dbe5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e6fb0718623ced3782e800e67badac5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmp_1_1_face.html">Face</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#a6e6fb0718623ced3782e800e67badac5">add_quad</a> (<a class="el" href="classpmp_1_1_vertex.html">Vertex</a> v0, <a class="el" href="classpmp_1_1_vertex.html">Vertex</a> v1, <a class="el" href="classpmp_1_1_vertex.html">Vertex</a> v2, <a class="el" href="classpmp_1_1_vertex.html">Vertex</a> v3)</td></tr>
<tr class="memdesc:a6e6fb0718623ced3782e800e67badac5"><td class="mdescLeft">&#160;</td><td class="mdescRight">add a new quad connecting vertices <code>v0</code>, <code>v1</code>, <code>v2</code>, <code>v3</code>  <br /></td></tr>
<tr class="separator:a6e6fb0718623ced3782e800e67badac5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Memory Management</div></td></tr>
<tr class="memitem:a005316b027701d5a1999209fc6a1f453"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#a005316b027701d5a1999209fc6a1f453">vertices_size</a> () const</td></tr>
<tr class="separator:a005316b027701d5a1999209fc6a1f453"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6f6842a96aab68705bae800bea3eae8"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#ab6f6842a96aab68705bae800bea3eae8">halfedges_size</a> () const</td></tr>
<tr class="separator:ab6f6842a96aab68705bae800bea3eae8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60e4af817e3a9bb25ce627275411717a"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#a60e4af817e3a9bb25ce627275411717a">edges_size</a> () const</td></tr>
<tr class="separator:a60e4af817e3a9bb25ce627275411717a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a045df1c7493495e832c01974f6bc01d6"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#a045df1c7493495e832c01974f6bc01d6">faces_size</a> () const</td></tr>
<tr class="separator:a045df1c7493495e832c01974f6bc01d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2538edd8437da799144eea8ba0a561f4"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#a2538edd8437da799144eea8ba0a561f4">n_vertices</a> () const</td></tr>
<tr class="separator:a2538edd8437da799144eea8ba0a561f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a006d64c9b0755da0afd525e9fbe0573f"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#a006d64c9b0755da0afd525e9fbe0573f">n_halfedges</a> () const</td></tr>
<tr class="separator:a006d64c9b0755da0afd525e9fbe0573f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08b03909e7ab3a1f72e089537ce353c6"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#a08b03909e7ab3a1f72e089537ce353c6">n_edges</a> () const</td></tr>
<tr class="separator:a08b03909e7ab3a1f72e089537ce353c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa18b9618188508bc2c5bb0fd81625880"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#aa18b9618188508bc2c5bb0fd81625880">n_faces</a> () const</td></tr>
<tr class="separator:aa18b9618188508bc2c5bb0fd81625880"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a2b7a58dc85678d08752945ff655362"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#a5a2b7a58dc85678d08752945ff655362">is_empty</a> () const</td></tr>
<tr class="separator:a5a2b7a58dc85678d08752945ff655362"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8bb3912a3ce86b15842e79d0b421204"><td class="memItemLeft" align="right" valign="top"><a id="ac8bb3912a3ce86b15842e79d0b421204" name="ac8bb3912a3ce86b15842e79d0b421204"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>clear</b> ()</td></tr>
<tr class="memdesc:ac8bb3912a3ce86b15842e79d0b421204"><td class="mdescLeft">&#160;</td><td class="mdescRight">clear mesh: remove all vertices, edges, faces <br /></td></tr>
<tr class="separator:ac8bb3912a3ce86b15842e79d0b421204"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f81a9a3690fcba7180fa860e0c2422f"><td class="memItemLeft" align="right" valign="top"><a id="a9f81a9a3690fcba7180fa860e0c2422f" name="a9f81a9a3690fcba7180fa860e0c2422f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>free_memory</b> ()</td></tr>
<tr class="memdesc:a9f81a9a3690fcba7180fa860e0c2422f"><td class="mdescLeft">&#160;</td><td class="mdescRight">remove unused memory from vectors <br /></td></tr>
<tr class="separator:a9f81a9a3690fcba7180fa860e0c2422f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ba773ee44e3fe291bcc7811e837852a"><td class="memItemLeft" align="right" valign="top"><a id="a5ba773ee44e3fe291bcc7811e837852a" name="a5ba773ee44e3fe291bcc7811e837852a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>reserve</b> (size_t nvertices, size_t nedges, size_t nfaces)</td></tr>
<tr class="memdesc:a5ba773ee44e3fe291bcc7811e837852a"><td class="mdescLeft">&#160;</td><td class="mdescRight">reserve memory (mainly used in file readers) <br /></td></tr>
<tr class="separator:a5ba773ee44e3fe291bcc7811e837852a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18ccfc2210e9d09621859d6f95381aaf"><td class="memItemLeft" align="right" valign="top"><a id="a18ccfc2210e9d09621859d6f95381aaf" name="a18ccfc2210e9d09621859d6f95381aaf"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>garbage_collection</b> ()</td></tr>
<tr class="memdesc:a18ccfc2210e9d09621859d6f95381aaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">remove deleted elements <br /></td></tr>
<tr class="separator:a18ccfc2210e9d09621859d6f95381aaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e92fd7fbcb7f8d00a67b3a38d32dc43"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#a6e92fd7fbcb7f8d00a67b3a38d32dc43">is_deleted</a> (<a class="el" href="classpmp_1_1_vertex.html">Vertex</a> v) const</td></tr>
<tr class="separator:a6e92fd7fbcb7f8d00a67b3a38d32dc43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad254f6af02142634deb39fa5bbc65d39"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#ad254f6af02142634deb39fa5bbc65d39">is_deleted</a> (<a class="el" href="classpmp_1_1_halfedge.html">Halfedge</a> h) const</td></tr>
<tr class="separator:ad254f6af02142634deb39fa5bbc65d39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b3401f7fc43215a63c78acdb1b4ed7c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#a7b3401f7fc43215a63c78acdb1b4ed7c">is_deleted</a> (<a class="el" href="classpmp_1_1_edge.html">Edge</a> e) const</td></tr>
<tr class="separator:a7b3401f7fc43215a63c78acdb1b4ed7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a737682e4d34e7d61aeb1105d3fd17626"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#a737682e4d34e7d61aeb1105d3fd17626">is_deleted</a> (<a class="el" href="classpmp_1_1_face.html">Face</a> f) const</td></tr>
<tr class="separator:a737682e4d34e7d61aeb1105d3fd17626"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec6665e506694c78cb4e33c629250eae"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#aec6665e506694c78cb4e33c629250eae">is_valid</a> (<a class="el" href="classpmp_1_1_vertex.html">Vertex</a> v) const</td></tr>
<tr class="separator:aec6665e506694c78cb4e33c629250eae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ae05a79983cb96b5a739875fc602e3f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#a1ae05a79983cb96b5a739875fc602e3f">is_valid</a> (<a class="el" href="classpmp_1_1_halfedge.html">Halfedge</a> h) const</td></tr>
<tr class="separator:a1ae05a79983cb96b5a739875fc602e3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ce65fa0b9a24e1ed45f5578f74016cd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#a1ce65fa0b9a24e1ed45f5578f74016cd">is_valid</a> (<a class="el" href="classpmp_1_1_edge.html">Edge</a> e) const</td></tr>
<tr class="separator:a1ce65fa0b9a24e1ed45f5578f74016cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad9d43c3b09e4dc9d004c8e2ac6fa3dd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#aad9d43c3b09e4dc9d004c8e2ac6fa3dd">is_valid</a> (<a class="el" href="classpmp_1_1_face.html">Face</a> f) const</td></tr>
<tr class="separator:aad9d43c3b09e4dc9d004c8e2ac6fa3dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Low-level connectivity</div></td></tr>
<tr class="memitem:af6bce4e4a93c05a02be9ca8dd842de43"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmp_1_1_halfedge.html">Halfedge</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#af6bce4e4a93c05a02be9ca8dd842de43">halfedge</a> (<a class="el" href="classpmp_1_1_vertex.html">Vertex</a> v) const</td></tr>
<tr class="separator:af6bce4e4a93c05a02be9ca8dd842de43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42b5f5cf1defc9f5c2f03b3784960f1f"><td class="memItemLeft" align="right" valign="top"><a id="a42b5f5cf1defc9f5c2f03b3784960f1f" name="a42b5f5cf1defc9f5c2f03b3784960f1f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>set_halfedge</b> (<a class="el" href="classpmp_1_1_vertex.html">Vertex</a> v, <a class="el" href="classpmp_1_1_halfedge.html">Halfedge</a> h)</td></tr>
<tr class="memdesc:a42b5f5cf1defc9f5c2f03b3784960f1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">set the outgoing halfedge of vertex <code>v</code> to <code>h</code> <br /></td></tr>
<tr class="separator:a42b5f5cf1defc9f5c2f03b3784960f1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc14569aa72d62aa569d3ef31053420d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#acc14569aa72d62aa569d3ef31053420d">is_boundary</a> (<a class="el" href="classpmp_1_1_vertex.html">Vertex</a> v) const</td></tr>
<tr class="separator:acc14569aa72d62aa569d3ef31053420d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf27870c55e439d315e7916dd92889d1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#acf27870c55e439d315e7916dd92889d1">is_isolated</a> (<a class="el" href="classpmp_1_1_vertex.html">Vertex</a> v) const</td></tr>
<tr class="separator:acf27870c55e439d315e7916dd92889d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac88fa768c6dd4e545df7bb105cd3c1b7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#ac88fa768c6dd4e545df7bb105cd3c1b7">is_manifold</a> (<a class="el" href="classpmp_1_1_vertex.html">Vertex</a> v) const</td></tr>
<tr class="separator:ac88fa768c6dd4e545df7bb105cd3c1b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a662504cbe67b5f9fd40b1ffe605d0ac7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmp_1_1_vertex.html">Vertex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#a662504cbe67b5f9fd40b1ffe605d0ac7">to_vertex</a> (<a class="el" href="classpmp_1_1_halfedge.html">Halfedge</a> h) const</td></tr>
<tr class="separator:a662504cbe67b5f9fd40b1ffe605d0ac7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55e2ad655b34779a1a18411c0df56580"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmp_1_1_vertex.html">Vertex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#a55e2ad655b34779a1a18411c0df56580">from_vertex</a> (<a class="el" href="classpmp_1_1_halfedge.html">Halfedge</a> h) const</td></tr>
<tr class="separator:a55e2ad655b34779a1a18411c0df56580"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae06490461e7ea2747acdc3ad3a4e66f2"><td class="memItemLeft" align="right" valign="top"><a id="ae06490461e7ea2747acdc3ad3a4e66f2" name="ae06490461e7ea2747acdc3ad3a4e66f2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>set_vertex</b> (<a class="el" href="classpmp_1_1_halfedge.html">Halfedge</a> h, <a class="el" href="classpmp_1_1_vertex.html">Vertex</a> v)</td></tr>
<tr class="memdesc:ae06490461e7ea2747acdc3ad3a4e66f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">sets the vertex the halfedge <code>h</code> points to to <code>v</code> <br /></td></tr>
<tr class="separator:ae06490461e7ea2747acdc3ad3a4e66f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab89ca2f5a06d4216412f355cb234311d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmp_1_1_face.html">Face</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#ab89ca2f5a06d4216412f355cb234311d">face</a> (<a class="el" href="classpmp_1_1_halfedge.html">Halfedge</a> h) const</td></tr>
<tr class="separator:ab89ca2f5a06d4216412f355cb234311d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a703f1846cc3664b6b28892088a110279"><td class="memItemLeft" align="right" valign="top"><a id="a703f1846cc3664b6b28892088a110279" name="a703f1846cc3664b6b28892088a110279"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>set_face</b> (<a class="el" href="classpmp_1_1_halfedge.html">Halfedge</a> h, <a class="el" href="classpmp_1_1_face.html">Face</a> f)</td></tr>
<tr class="memdesc:a703f1846cc3664b6b28892088a110279"><td class="mdescLeft">&#160;</td><td class="mdescRight">sets the incident face to halfedge <code>h</code> to <code>f</code> <br /></td></tr>
<tr class="separator:a703f1846cc3664b6b28892088a110279"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f5891098f965b93a2c9fd6927301be6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmp_1_1_halfedge.html">Halfedge</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#a6f5891098f965b93a2c9fd6927301be6">next_halfedge</a> (<a class="el" href="classpmp_1_1_halfedge.html">Halfedge</a> h) const</td></tr>
<tr class="separator:a6f5891098f965b93a2c9fd6927301be6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50cc2a87a46ddd1ee7f4b29b196a0fe5"><td class="memItemLeft" align="right" valign="top"><a id="a50cc2a87a46ddd1ee7f4b29b196a0fe5" name="a50cc2a87a46ddd1ee7f4b29b196a0fe5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>set_next_halfedge</b> (<a class="el" href="classpmp_1_1_halfedge.html">Halfedge</a> h, <a class="el" href="classpmp_1_1_halfedge.html">Halfedge</a> nh)</td></tr>
<tr class="memdesc:a50cc2a87a46ddd1ee7f4b29b196a0fe5"><td class="mdescLeft">&#160;</td><td class="mdescRight">sets the next halfedge of <code>h</code> within the face to <code>nh</code> <br /></td></tr>
<tr class="separator:a50cc2a87a46ddd1ee7f4b29b196a0fe5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc91c6a43899bc1dfeb880d23c17e2d6"><td class="memItemLeft" align="right" valign="top"><a id="acc91c6a43899bc1dfeb880d23c17e2d6" name="acc91c6a43899bc1dfeb880d23c17e2d6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>set_prev_halfedge</b> (<a class="el" href="classpmp_1_1_halfedge.html">Halfedge</a> h, <a class="el" href="classpmp_1_1_halfedge.html">Halfedge</a> ph)</td></tr>
<tr class="memdesc:acc91c6a43899bc1dfeb880d23c17e2d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">sets the previous halfedge of <code>h</code> and the next halfedge of <code>ph</code> to <code>nh</code> <br /></td></tr>
<tr class="separator:acc91c6a43899bc1dfeb880d23c17e2d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab947bd972c6571ed2fff6e6d30dab257"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmp_1_1_halfedge.html">Halfedge</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#ab947bd972c6571ed2fff6e6d30dab257">prev_halfedge</a> (<a class="el" href="classpmp_1_1_halfedge.html">Halfedge</a> h) const</td></tr>
<tr class="separator:ab947bd972c6571ed2fff6e6d30dab257"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a932eceb1f8fbf1ef8a55d408238d2b07"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmp_1_1_halfedge.html">Halfedge</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#a932eceb1f8fbf1ef8a55d408238d2b07">opposite_halfedge</a> (<a class="el" href="classpmp_1_1_halfedge.html">Halfedge</a> h) const</td></tr>
<tr class="separator:a932eceb1f8fbf1ef8a55d408238d2b07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a588e0f69d96bd584043546cfd5e7fdc0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmp_1_1_halfedge.html">Halfedge</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#a588e0f69d96bd584043546cfd5e7fdc0">ccw_rotated_halfedge</a> (<a class="el" href="classpmp_1_1_halfedge.html">Halfedge</a> h) const</td></tr>
<tr class="separator:a588e0f69d96bd584043546cfd5e7fdc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf30244b0452c72345b969428ea77d9d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmp_1_1_halfedge.html">Halfedge</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#adf30244b0452c72345b969428ea77d9d">cw_rotated_halfedge</a> (<a class="el" href="classpmp_1_1_halfedge.html">Halfedge</a> h) const</td></tr>
<tr class="separator:adf30244b0452c72345b969428ea77d9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad458db917bf85de7ac73bc17808daa14"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmp_1_1_edge.html">Edge</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#ad458db917bf85de7ac73bc17808daa14">edge</a> (<a class="el" href="classpmp_1_1_halfedge.html">Halfedge</a> h) const</td></tr>
<tr class="separator:ad458db917bf85de7ac73bc17808daa14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb749d4b88b89e5693809cbbc5ed015d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#adb749d4b88b89e5693809cbbc5ed015d">is_boundary</a> (<a class="el" href="classpmp_1_1_halfedge.html">Halfedge</a> h) const</td></tr>
<tr class="separator:adb749d4b88b89e5693809cbbc5ed015d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cc004bd087fc53cf1b3386269578688"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmp_1_1_halfedge.html">Halfedge</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#a3cc004bd087fc53cf1b3386269578688">halfedge</a> (<a class="el" href="classpmp_1_1_edge.html">Edge</a> e, unsigned int i) const</td></tr>
<tr class="separator:a3cc004bd087fc53cf1b3386269578688"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecbaa899c528570e821a1f1aad56650b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmp_1_1_vertex.html">Vertex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#aecbaa899c528570e821a1f1aad56650b">vertex</a> (<a class="el" href="classpmp_1_1_edge.html">Edge</a> e, unsigned int i) const</td></tr>
<tr class="separator:aecbaa899c528570e821a1f1aad56650b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5c4d6fe9f6984ff83ee80b05d1208ed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmp_1_1_face.html">Face</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#ae5c4d6fe9f6984ff83ee80b05d1208ed">face</a> (<a class="el" href="classpmp_1_1_edge.html">Edge</a> e, unsigned int i) const</td></tr>
<tr class="separator:ae5c4d6fe9f6984ff83ee80b05d1208ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d473cb489519535b6812172305e1b7f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#a5d473cb489519535b6812172305e1b7f">is_boundary</a> (<a class="el" href="classpmp_1_1_edge.html">Edge</a> e) const</td></tr>
<tr class="separator:a5d473cb489519535b6812172305e1b7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72dd99a11016012e1afaed4b581a4f64"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmp_1_1_halfedge.html">Halfedge</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#a72dd99a11016012e1afaed4b581a4f64">halfedge</a> (<a class="el" href="classpmp_1_1_face.html">Face</a> f) const</td></tr>
<tr class="separator:a72dd99a11016012e1afaed4b581a4f64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a575bb5753f8383f7e70d40cba1f076d0"><td class="memItemLeft" align="right" valign="top"><a id="a575bb5753f8383f7e70d40cba1f076d0" name="a575bb5753f8383f7e70d40cba1f076d0"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>set_halfedge</b> (<a class="el" href="classpmp_1_1_face.html">Face</a> f, <a class="el" href="classpmp_1_1_halfedge.html">Halfedge</a> h)</td></tr>
<tr class="memdesc:a575bb5753f8383f7e70d40cba1f076d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">sets the halfedge of face <code>f</code> to <code>h</code> <br /></td></tr>
<tr class="separator:a575bb5753f8383f7e70d40cba1f076d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaf1a18244ce7378e3b1198dccc7c032"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#acaf1a18244ce7378e3b1198dccc7c032">is_boundary</a> (<a class="el" href="classpmp_1_1_face.html">Face</a> f) const</td></tr>
<tr class="separator:acaf1a18244ce7378e3b1198dccc7c032"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Property handling</div></td></tr>
<tr class="memitem:a901e73ce0a53ab3c3dd0067501556996"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a901e73ce0a53ab3c3dd0067501556996"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpmp_1_1_vertex_property.html">VertexProperty</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#a901e73ce0a53ab3c3dd0067501556996">add_vertex_property</a> (const std::string &amp;name, const T t=T())</td></tr>
<tr class="memdesc:a901e73ce0a53ab3c3dd0067501556996"><td class="mdescLeft">&#160;</td><td class="mdescRight">add a vertex property of type <code>T</code> with name <code>name</code> and default value <code>t</code>.  <br /></td></tr>
<tr class="separator:a901e73ce0a53ab3c3dd0067501556996"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a617c33083979c72bacd5fc6c798179cb"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a617c33083979c72bacd5fc6c798179cb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpmp_1_1_vertex_property.html">VertexProperty</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#a617c33083979c72bacd5fc6c798179cb">get_vertex_property</a> (const std::string &amp;name) const</td></tr>
<tr class="memdesc:a617c33083979c72bacd5fc6c798179cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the vertex property named <code>name</code> of type <code>T</code>.  <br /></td></tr>
<tr class="separator:a617c33083979c72bacd5fc6c798179cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4465582636194110ddbce299daebeb4a"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a4465582636194110ddbce299daebeb4a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpmp_1_1_vertex_property.html">VertexProperty</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#a4465582636194110ddbce299daebeb4a">vertex_property</a> (const std::string &amp;name, const T t=T())</td></tr>
<tr class="memdesc:a4465582636194110ddbce299daebeb4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">if a vertex property of type <code>T</code> with name <code>name</code> exists, it is returned.  <br /></td></tr>
<tr class="separator:a4465582636194110ddbce299daebeb4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6253cef536ace70bb020cacfd3dee5fa"><td class="memTemplParams" colspan="2"><a id="a6253cef536ace70bb020cacfd3dee5fa" name="a6253cef536ace70bb020cacfd3dee5fa"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a6253cef536ace70bb020cacfd3dee5fa"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>remove_vertex_property</b> (<a class="el" href="classpmp_1_1_vertex_property.html">VertexProperty</a>&lt; T &gt; &amp;p)</td></tr>
<tr class="memdesc:a6253cef536ace70bb020cacfd3dee5fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">remove the vertex property <code>p</code> <br /></td></tr>
<tr class="separator:a6253cef536ace70bb020cacfd3dee5fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a550b8c050b02f9f0d88aec8ad1ac42ae"><td class="memItemLeft" align="right" valign="top"><a id="a550b8c050b02f9f0d88aec8ad1ac42ae" name="a550b8c050b02f9f0d88aec8ad1ac42ae"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>has_vertex_property</b> (const std::string &amp;name) const</td></tr>
<tr class="memdesc:a550b8c050b02f9f0d88aec8ad1ac42ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">does the mesh have a vertex property with name <code>name</code>? <br /></td></tr>
<tr class="separator:a550b8c050b02f9f0d88aec8ad1ac42ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21fcc50b5371ceede90be575f33c35a7"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a21fcc50b5371ceede90be575f33c35a7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpmp_1_1_halfedge_property.html">HalfedgeProperty</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#a21fcc50b5371ceede90be575f33c35a7">add_halfedge_property</a> (const std::string &amp;name, const T t=T())</td></tr>
<tr class="memdesc:a21fcc50b5371ceede90be575f33c35a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">add a halfedge property of type <code>T</code> with name <code>name</code> and default value <code>t</code>.  <br /></td></tr>
<tr class="separator:a21fcc50b5371ceede90be575f33c35a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc951d12a195401ac66e813fde413438"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:adc951d12a195401ac66e813fde413438"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpmp_1_1_edge_property.html">EdgeProperty</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#adc951d12a195401ac66e813fde413438">add_edge_property</a> (const std::string &amp;name, const T t=T())</td></tr>
<tr class="memdesc:adc951d12a195401ac66e813fde413438"><td class="mdescLeft">&#160;</td><td class="mdescRight">add a edge property of type <code>T</code> with name <code>name</code> and default value <code>t</code>.  <br /></td></tr>
<tr class="separator:adc951d12a195401ac66e813fde413438"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabbb1cfa4ad230b4dd6677f480763d5b"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:aabbb1cfa4ad230b4dd6677f480763d5b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpmp_1_1_halfedge_property.html">HalfedgeProperty</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#aabbb1cfa4ad230b4dd6677f480763d5b">get_halfedge_property</a> (const std::string &amp;name) const</td></tr>
<tr class="memdesc:aabbb1cfa4ad230b4dd6677f480763d5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the halfedge property named <code>name</code> of type <code>T</code>.  <br /></td></tr>
<tr class="separator:aabbb1cfa4ad230b4dd6677f480763d5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a574931d8d9df34ff1b54351131f41bad"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a574931d8d9df34ff1b54351131f41bad"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpmp_1_1_edge_property.html">EdgeProperty</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#a574931d8d9df34ff1b54351131f41bad">get_edge_property</a> (const std::string &amp;name) const</td></tr>
<tr class="memdesc:a574931d8d9df34ff1b54351131f41bad"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the edge property named <code>name</code> of type <code>T</code>.  <br /></td></tr>
<tr class="separator:a574931d8d9df34ff1b54351131f41bad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7f9114394d2d9f129fe510f0548bc8d"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ac7f9114394d2d9f129fe510f0548bc8d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpmp_1_1_halfedge_property.html">HalfedgeProperty</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#ac7f9114394d2d9f129fe510f0548bc8d">halfedge_property</a> (const std::string &amp;name, const T t=T())</td></tr>
<tr class="memdesc:ac7f9114394d2d9f129fe510f0548bc8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">if a halfedge property of type <code>T</code> with name <code>name</code> exists, it is returned.  <br /></td></tr>
<tr class="separator:ac7f9114394d2d9f129fe510f0548bc8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab72c709f83f75c767b2c48727f2db619"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ab72c709f83f75c767b2c48727f2db619"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpmp_1_1_edge_property.html">EdgeProperty</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#ab72c709f83f75c767b2c48727f2db619">edge_property</a> (const std::string &amp;name, const T t=T())</td></tr>
<tr class="memdesc:ab72c709f83f75c767b2c48727f2db619"><td class="mdescLeft">&#160;</td><td class="mdescRight">if an edge property of type <code>T</code> with name <code>name</code> exists, it is returned.  <br /></td></tr>
<tr class="separator:ab72c709f83f75c767b2c48727f2db619"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a738b7b5ee1edeb4f25d331bd8c092337"><td class="memTemplParams" colspan="2"><a id="a738b7b5ee1edeb4f25d331bd8c092337" name="a738b7b5ee1edeb4f25d331bd8c092337"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a738b7b5ee1edeb4f25d331bd8c092337"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>remove_halfedge_property</b> (<a class="el" href="classpmp_1_1_halfedge_property.html">HalfedgeProperty</a>&lt; T &gt; &amp;p)</td></tr>
<tr class="memdesc:a738b7b5ee1edeb4f25d331bd8c092337"><td class="mdescLeft">&#160;</td><td class="mdescRight">remove the halfedge property <code>p</code> <br /></td></tr>
<tr class="separator:a738b7b5ee1edeb4f25d331bd8c092337"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a926a3b395e6b8b3b85a65ae5108a0382"><td class="memItemLeft" align="right" valign="top"><a id="a926a3b395e6b8b3b85a65ae5108a0382" name="a926a3b395e6b8b3b85a65ae5108a0382"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>has_halfedge_property</b> (const std::string &amp;name) const</td></tr>
<tr class="memdesc:a926a3b395e6b8b3b85a65ae5108a0382"><td class="mdescLeft">&#160;</td><td class="mdescRight">does the mesh have a halfedge property with name <code>name</code>? <br /></td></tr>
<tr class="separator:a926a3b395e6b8b3b85a65ae5108a0382"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3eeefd3f1bac92af03188fb814b23f4c"><td class="memTemplParams" colspan="2"><a id="a3eeefd3f1bac92af03188fb814b23f4c" name="a3eeefd3f1bac92af03188fb814b23f4c"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a3eeefd3f1bac92af03188fb814b23f4c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>remove_edge_property</b> (<a class="el" href="classpmp_1_1_edge_property.html">EdgeProperty</a>&lt; T &gt; &amp;p)</td></tr>
<tr class="memdesc:a3eeefd3f1bac92af03188fb814b23f4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">remove the edge property <code>p</code> <br /></td></tr>
<tr class="separator:a3eeefd3f1bac92af03188fb814b23f4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cb2082e1b047413de477cc563adb7a6"><td class="memItemLeft" align="right" valign="top"><a id="a4cb2082e1b047413de477cc563adb7a6" name="a4cb2082e1b047413de477cc563adb7a6"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>has_edge_property</b> (const std::string &amp;name) const</td></tr>
<tr class="memdesc:a4cb2082e1b047413de477cc563adb7a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">does the mesh have an edge property with name <code>name</code>? <br /></td></tr>
<tr class="separator:a4cb2082e1b047413de477cc563adb7a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a555e3a8f59c76a204cb23146e30fc28c"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#a555e3a8f59c76a204cb23146e30fc28c">vertex_properties</a> () const</td></tr>
<tr class="separator:a555e3a8f59c76a204cb23146e30fc28c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a714ffe7af34bd510864ba3586acabc"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#a9a714ffe7af34bd510864ba3586acabc">halfedge_properties</a> () const</td></tr>
<tr class="separator:a9a714ffe7af34bd510864ba3586acabc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bd4a8d297474575c2089ccae456d31a"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#a6bd4a8d297474575c2089ccae456d31a">edge_properties</a> () const</td></tr>
<tr class="separator:a6bd4a8d297474575c2089ccae456d31a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9703ad1a174de89c27fe185153b456d5"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a9703ad1a174de89c27fe185153b456d5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpmp_1_1_face_property.html">FaceProperty</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#a9703ad1a174de89c27fe185153b456d5">add_face_property</a> (const std::string &amp;name, const T t=T())</td></tr>
<tr class="memdesc:a9703ad1a174de89c27fe185153b456d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">add a face property of type <code>T</code> with name <code>name</code> and default value <code>t</code>.  <br /></td></tr>
<tr class="separator:a9703ad1a174de89c27fe185153b456d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fe9e716e46c8ed83fa1c9891aab71bd"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a2fe9e716e46c8ed83fa1c9891aab71bd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpmp_1_1_face_property.html">FaceProperty</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#a2fe9e716e46c8ed83fa1c9891aab71bd">get_face_property</a> (const std::string &amp;name) const</td></tr>
<tr class="memdesc:a2fe9e716e46c8ed83fa1c9891aab71bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the face property named <code>name</code> of type <code>T</code>.  <br /></td></tr>
<tr class="separator:a2fe9e716e46c8ed83fa1c9891aab71bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94dfa3b6c130d2d2689c0fc55bc73419"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a94dfa3b6c130d2d2689c0fc55bc73419"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpmp_1_1_face_property.html">FaceProperty</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#a94dfa3b6c130d2d2689c0fc55bc73419">face_property</a> (const std::string &amp;name, const T t=T())</td></tr>
<tr class="memdesc:a94dfa3b6c130d2d2689c0fc55bc73419"><td class="mdescLeft">&#160;</td><td class="mdescRight">if a face property of type <code>T</code> with name <code>name</code> exists, it is returned.  <br /></td></tr>
<tr class="separator:a94dfa3b6c130d2d2689c0fc55bc73419"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a888b18cf5fcb3776ee59708d317bb323"><td class="memTemplParams" colspan="2"><a id="a888b18cf5fcb3776ee59708d317bb323" name="a888b18cf5fcb3776ee59708d317bb323"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a888b18cf5fcb3776ee59708d317bb323"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>remove_face_property</b> (<a class="el" href="classpmp_1_1_face_property.html">FaceProperty</a>&lt; T &gt; &amp;p)</td></tr>
<tr class="memdesc:a888b18cf5fcb3776ee59708d317bb323"><td class="mdescLeft">&#160;</td><td class="mdescRight">remove the face property <code>p</code> <br /></td></tr>
<tr class="separator:a888b18cf5fcb3776ee59708d317bb323"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac13c5f43df27191c1758116ede0742e8"><td class="memItemLeft" align="right" valign="top"><a id="ac13c5f43df27191c1758116ede0742e8" name="ac13c5f43df27191c1758116ede0742e8"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>has_face_property</b> (const std::string &amp;name) const</td></tr>
<tr class="memdesc:ac13c5f43df27191c1758116ede0742e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">does the mesh have a face property with name <code>name</code>? <br /></td></tr>
<tr class="separator:ac13c5f43df27191c1758116ede0742e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b190ab20c7ad53b7892747f9f3e5f56"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#a4b190ab20c7ad53b7892747f9f3e5f56">face_properties</a> () const</td></tr>
<tr class="separator:a4b190ab20c7ad53b7892747f9f3e5f56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Iterators and circulators</div></td></tr>
<tr class="memitem:ae74e42fa45975f08ae79f27b82d79614"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmp_1_1_surface_mesh_1_1_vertex_iterator.html">VertexIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#ae74e42fa45975f08ae79f27b82d79614">vertices_begin</a> () const</td></tr>
<tr class="separator:ae74e42fa45975f08ae79f27b82d79614"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea3629fcd038ae4cf98ec4c60094da9e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmp_1_1_surface_mesh_1_1_vertex_iterator.html">VertexIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#aea3629fcd038ae4cf98ec4c60094da9e">vertices_end</a> () const</td></tr>
<tr class="separator:aea3629fcd038ae4cf98ec4c60094da9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c155f3e7e2ceabdfb7b5457e891ab9a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmp_1_1_surface_mesh_1_1_vertex_container.html">VertexContainer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#a2c155f3e7e2ceabdfb7b5457e891ab9a">vertices</a> () const</td></tr>
<tr class="separator:a2c155f3e7e2ceabdfb7b5457e891ab9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7c6741949eb649d31a524fe78aa21bf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmp_1_1_surface_mesh_1_1_halfedge_iterator.html">HalfedgeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#aa7c6741949eb649d31a524fe78aa21bf">halfedges_begin</a> () const</td></tr>
<tr class="separator:aa7c6741949eb649d31a524fe78aa21bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae958f4ac33e405602a5bb138992e99fa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmp_1_1_surface_mesh_1_1_halfedge_iterator.html">HalfedgeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#ae958f4ac33e405602a5bb138992e99fa">halfedges_end</a> () const</td></tr>
<tr class="separator:ae958f4ac33e405602a5bb138992e99fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74a649abba6e8f2ff77d4a56c36eecc1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmp_1_1_surface_mesh_1_1_halfedge_container.html">HalfedgeContainer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#a74a649abba6e8f2ff77d4a56c36eecc1">halfedges</a> () const</td></tr>
<tr class="separator:a74a649abba6e8f2ff77d4a56c36eecc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b369fd79dede60706600e60b4788fc9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmp_1_1_surface_mesh_1_1_edge_iterator.html">EdgeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#a5b369fd79dede60706600e60b4788fc9">edges_begin</a> () const</td></tr>
<tr class="separator:a5b369fd79dede60706600e60b4788fc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a155a6587f1e778e8a7756b066965369d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmp_1_1_surface_mesh_1_1_edge_iterator.html">EdgeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#a155a6587f1e778e8a7756b066965369d">edges_end</a> () const</td></tr>
<tr class="separator:a155a6587f1e778e8a7756b066965369d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0badaef8b3f0fab59125eedb12e5556e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmp_1_1_surface_mesh_1_1_edge_container.html">EdgeContainer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#a0badaef8b3f0fab59125eedb12e5556e">edges</a> () const</td></tr>
<tr class="separator:a0badaef8b3f0fab59125eedb12e5556e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19df4baf50796afd22f7a238fb8fba47"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmp_1_1_surface_mesh_1_1_vertex_around_vertex_circulator.html">VertexAroundVertexCirculator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#a19df4baf50796afd22f7a238fb8fba47">vertices</a> (<a class="el" href="classpmp_1_1_vertex.html">Vertex</a> v) const</td></tr>
<tr class="separator:a19df4baf50796afd22f7a238fb8fba47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a182905105e2b83d232bbcacf0430b946"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmp_1_1_surface_mesh_1_1_edge_around_vertex_circulator.html">EdgeAroundVertexCirculator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#a182905105e2b83d232bbcacf0430b946">edges</a> (<a class="el" href="classpmp_1_1_vertex.html">Vertex</a> v) const</td></tr>
<tr class="separator:a182905105e2b83d232bbcacf0430b946"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2e6e4cb42864442169e18bc1fbb8827"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmp_1_1_surface_mesh_1_1_halfedge_around_vertex_circulator.html">HalfedgeAroundVertexCirculator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#ad2e6e4cb42864442169e18bc1fbb8827">halfedges</a> (<a class="el" href="classpmp_1_1_vertex.html">Vertex</a> v) const</td></tr>
<tr class="separator:ad2e6e4cb42864442169e18bc1fbb8827"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f8263f0242eb7044ea5028d80ddb773"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmp_1_1_surface_mesh_1_1_face_iterator.html">FaceIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#a5f8263f0242eb7044ea5028d80ddb773">faces_begin</a> () const</td></tr>
<tr class="separator:a5f8263f0242eb7044ea5028d80ddb773"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf78c04ead850dd21d04703d5450f005"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmp_1_1_surface_mesh_1_1_face_iterator.html">FaceIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#abf78c04ead850dd21d04703d5450f005">faces_end</a> () const</td></tr>
<tr class="separator:abf78c04ead850dd21d04703d5450f005"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50c0bab596df80894c1c694912193a5f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmp_1_1_surface_mesh_1_1_face_container.html">FaceContainer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#a50c0bab596df80894c1c694912193a5f">faces</a> () const</td></tr>
<tr class="separator:a50c0bab596df80894c1c694912193a5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a972e42a9966f5ce484a5364fc6f0a0f0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmp_1_1_surface_mesh_1_1_face_around_vertex_circulator.html">FaceAroundVertexCirculator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#a972e42a9966f5ce484a5364fc6f0a0f0">faces</a> (<a class="el" href="classpmp_1_1_vertex.html">Vertex</a> v) const</td></tr>
<tr class="separator:a972e42a9966f5ce484a5364fc6f0a0f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d7a2f713bc33199c572c5e86d50e379"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmp_1_1_surface_mesh_1_1_vertex_around_face_circulator.html">VertexAroundFaceCirculator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#a5d7a2f713bc33199c572c5e86d50e379">vertices</a> (<a class="el" href="classpmp_1_1_face.html">Face</a> f) const</td></tr>
<tr class="separator:a5d7a2f713bc33199c572c5e86d50e379"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b441eb9b6cad9459f68afe6265e72ed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmp_1_1_surface_mesh_1_1_halfedge_around_face_circulator.html">HalfedgeAroundFaceCirculator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#a1b441eb9b6cad9459f68afe6265e72ed">halfedges</a> (<a class="el" href="classpmp_1_1_face.html">Face</a> f) const</td></tr>
<tr class="separator:a1b441eb9b6cad9459f68afe6265e72ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Higher-level Topological Operations</div></td></tr>
<tr class="memitem:a8ee3d85c54f6a3b34678b94847e557ed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmp_1_1_halfedge.html">Halfedge</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#a8ee3d85c54f6a3b34678b94847e557ed">insert_vertex</a> (<a class="el" href="classpmp_1_1_edge.html">Edge</a> e, const <a class="el" href="group__core.html#ga4fc38b084567aed726be776958bfcc78">Point</a> &amp;p)</td></tr>
<tr class="memdesc:a8ee3d85c54f6a3b34678b94847e557ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subdivide the edge <code>e</code> = (v0,v1) by splitting it into the two edge (v0,p) and (p,v1).  <br /></td></tr>
<tr class="separator:a8ee3d85c54f6a3b34678b94847e557ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fdde5d6bfaac76a7dafb9c7fb1b01bd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmp_1_1_halfedge.html">Halfedge</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#a3fdde5d6bfaac76a7dafb9c7fb1b01bd">insert_vertex</a> (<a class="el" href="classpmp_1_1_edge.html">Edge</a> e, <a class="el" href="classpmp_1_1_vertex.html">Vertex</a> v)</td></tr>
<tr class="memdesc:a3fdde5d6bfaac76a7dafb9c7fb1b01bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subdivide the edge <code>e</code> = (v0,v1) by splitting it into the two edge (v0,v) and (v,v1).  <br /></td></tr>
<tr class="separator:a3fdde5d6bfaac76a7dafb9c7fb1b01bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36b01ea47ba079cb27b784fd6c8341d8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmp_1_1_halfedge.html">Halfedge</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#a36b01ea47ba079cb27b784fd6c8341d8">insert_vertex</a> (<a class="el" href="classpmp_1_1_halfedge.html">Halfedge</a> h0, <a class="el" href="classpmp_1_1_vertex.html">Vertex</a> v)</td></tr>
<tr class="memdesc:a36b01ea47ba079cb27b784fd6c8341d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subdivide the halfedge <code>h</code> = (v0,v1) by splitting it into the two halfedges (v0,v) and (v,v1).  <br /></td></tr>
<tr class="separator:a36b01ea47ba079cb27b784fd6c8341d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfd9a60f741921a9f1a00a36ba148449"><td class="memItemLeft" align="right" valign="top"><a id="abfd9a60f741921a9f1a00a36ba148449" name="abfd9a60f741921a9f1a00a36ba148449"></a>
<a class="el" href="classpmp_1_1_halfedge.html">Halfedge</a>&#160;</td><td class="memItemRight" valign="bottom"><b>find_halfedge</b> (<a class="el" href="classpmp_1_1_vertex.html">Vertex</a> start, <a class="el" href="classpmp_1_1_vertex.html">Vertex</a> end) const</td></tr>
<tr class="memdesc:abfd9a60f741921a9f1a00a36ba148449"><td class="mdescLeft">&#160;</td><td class="mdescRight">find the halfedge from start to end <br /></td></tr>
<tr class="separator:abfd9a60f741921a9f1a00a36ba148449"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b0b077951dfbb03218fbabeb288814d"><td class="memItemLeft" align="right" valign="top"><a id="a6b0b077951dfbb03218fbabeb288814d" name="a6b0b077951dfbb03218fbabeb288814d"></a>
<a class="el" href="classpmp_1_1_edge.html">Edge</a>&#160;</td><td class="memItemRight" valign="bottom"><b>find_edge</b> (<a class="el" href="classpmp_1_1_vertex.html">Vertex</a> a, <a class="el" href="classpmp_1_1_vertex.html">Vertex</a> b) const</td></tr>
<tr class="memdesc:a6b0b077951dfbb03218fbabeb288814d"><td class="mdescLeft">&#160;</td><td class="mdescRight">find the edge (a,b) <br /></td></tr>
<tr class="separator:a6b0b077951dfbb03218fbabeb288814d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cede937c41f63448522e8522f7d65a5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#a9cede937c41f63448522e8522f7d65a5">is_triangle_mesh</a> () const</td></tr>
<tr class="separator:a9cede937c41f63448522e8522f7d65a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a85b726b7fde45bfec81127fc85c042"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#a0a85b726b7fde45bfec81127fc85c042">is_quad_mesh</a> () const</td></tr>
<tr class="separator:a0a85b726b7fde45bfec81127fc85c042"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ec6d4a3b869975acb3e749bacd54e12"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#a6ec6d4a3b869975acb3e749bacd54e12">is_collapse_ok</a> (<a class="el" href="classpmp_1_1_halfedge.html">Halfedge</a> v0v1) const</td></tr>
<tr class="separator:a6ec6d4a3b869975acb3e749bacd54e12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5f0d7874e4fe8878e44fd56ad7d3b23"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#ac5f0d7874e4fe8878e44fd56ad7d3b23">collapse</a> (<a class="el" href="classpmp_1_1_halfedge.html">Halfedge</a> h)</td></tr>
<tr class="memdesc:ac5f0d7874e4fe8878e44fd56ad7d3b23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collapse the halfedge <code>h</code> by moving its start vertex into its target vertex.  <br /></td></tr>
<tr class="separator:ac5f0d7874e4fe8878e44fd56ad7d3b23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11eac1c73cdf1ff27e223fbce181e5a0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#a11eac1c73cdf1ff27e223fbce181e5a0">is_removal_ok</a> (<a class="el" href="classpmp_1_1_edge.html">Edge</a> e) const</td></tr>
<tr class="separator:a11eac1c73cdf1ff27e223fbce181e5a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0438b9632f38f9216e99968de0091dc8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#a0438b9632f38f9216e99968de0091dc8">remove_edge</a> (<a class="el" href="classpmp_1_1_edge.html">Edge</a> e)</td></tr>
<tr class="memdesc:a0438b9632f38f9216e99968de0091dc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove edge and merge its two incident faces into one.  <br /></td></tr>
<tr class="separator:a0438b9632f38f9216e99968de0091dc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93802d22c9ef77e8bd2fcf3c981713f4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmp_1_1_vertex.html">Vertex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#a93802d22c9ef77e8bd2fcf3c981713f4">split</a> (<a class="el" href="classpmp_1_1_face.html">Face</a> f, const <a class="el" href="group__core.html#ga4fc38b084567aed726be776958bfcc78">Point</a> &amp;p)</td></tr>
<tr class="memdesc:a93802d22c9ef77e8bd2fcf3c981713f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split the face <code>f</code> by first adding point <code>p</code> to the mesh and then inserting edges between <code>p</code> and the vertices of <code>f</code>.  <br /></td></tr>
<tr class="separator:a93802d22c9ef77e8bd2fcf3c981713f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9080aac7bc4e23d952ccea7335d4550"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#af9080aac7bc4e23d952ccea7335d4550">split</a> (<a class="el" href="classpmp_1_1_face.html">Face</a> f, <a class="el" href="classpmp_1_1_vertex.html">Vertex</a> v)</td></tr>
<tr class="memdesc:af9080aac7bc4e23d952ccea7335d4550"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split the face <code>f</code> by inserting edges between <code>v</code> and the vertices of <code>f</code>.  <br /></td></tr>
<tr class="separator:af9080aac7bc4e23d952ccea7335d4550"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50a3bf2eb0717d2315c4fb98d46ec2ef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmp_1_1_halfedge.html">Halfedge</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#a50a3bf2eb0717d2315c4fb98d46ec2ef">split</a> (<a class="el" href="classpmp_1_1_edge.html">Edge</a> e, const <a class="el" href="group__core.html#ga4fc38b084567aed726be776958bfcc78">Point</a> &amp;p)</td></tr>
<tr class="memdesc:a50a3bf2eb0717d2315c4fb98d46ec2ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split the edge <code>e</code> by first adding point <code>p</code> to the mesh and then connecting it to the two vertices of the adjacent triangles that are opposite to edge <code>e</code>.  <br /></td></tr>
<tr class="separator:a50a3bf2eb0717d2315c4fb98d46ec2ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e4a45fbb9a2a0c07a24bae805e9b2ee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmp_1_1_halfedge.html">Halfedge</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#a9e4a45fbb9a2a0c07a24bae805e9b2ee">split</a> (<a class="el" href="classpmp_1_1_edge.html">Edge</a> e, <a class="el" href="classpmp_1_1_vertex.html">Vertex</a> v)</td></tr>
<tr class="memdesc:a9e4a45fbb9a2a0c07a24bae805e9b2ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split the edge <code>e</code> by connecting vertex <code>v</code> it to the two vertices of the adjacent triangles that are opposite to edge <code>e</code>.  <br /></td></tr>
<tr class="separator:a9e4a45fbb9a2a0c07a24bae805e9b2ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ded6c774cb197b607f23bba25aa876a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmp_1_1_halfedge.html">Halfedge</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#a7ded6c774cb197b607f23bba25aa876a">insert_edge</a> (<a class="el" href="classpmp_1_1_halfedge.html">Halfedge</a> h0, <a class="el" href="classpmp_1_1_halfedge.html">Halfedge</a> h1)</td></tr>
<tr class="memdesc:a7ded6c774cb197b607f23bba25aa876a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert edge between the to-vertices of <code>h0</code> and <code>h1</code>.  <br /></td></tr>
<tr class="separator:a7ded6c774cb197b607f23bba25aa876a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d7b1645c59f855683a01a8f1b87e6da"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#a4d7b1645c59f855683a01a8f1b87e6da">is_flip_ok</a> (<a class="el" href="classpmp_1_1_edge.html">Edge</a> e) const</td></tr>
<tr class="memdesc:a4d7b1645c59f855683a01a8f1b87e6da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether flipping edge <code>e</code> is topologically OK.  <br /></td></tr>
<tr class="separator:a4d7b1645c59f855683a01a8f1b87e6da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac689cb1b5d5c7e2ab309c15e1388349a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#ac689cb1b5d5c7e2ab309c15e1388349a">flip</a> (<a class="el" href="classpmp_1_1_edge.html">Edge</a> e)</td></tr>
<tr class="memdesc:ac689cb1b5d5c7e2ab309c15e1388349a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flip the edge <code>e</code> .  <br /></td></tr>
<tr class="separator:ac689cb1b5d5c7e2ab309c15e1388349a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a519feed0e53b7e995957cf6b45871aa7"><td class="memItemLeft" align="right" valign="top"><a id="a519feed0e53b7e995957cf6b45871aa7" name="a519feed0e53b7e995957cf6b45871aa7"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>valence</b> (<a class="el" href="classpmp_1_1_vertex.html">Vertex</a> v) const</td></tr>
<tr class="memdesc:a519feed0e53b7e995957cf6b45871aa7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the valence of vertex <code>v</code> (number of incident edges). <br /></td></tr>
<tr class="separator:a519feed0e53b7e995957cf6b45871aa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0176af2f62bac6c5d96ccf90eb16e32"><td class="memItemLeft" align="right" valign="top"><a id="ab0176af2f62bac6c5d96ccf90eb16e32" name="ab0176af2f62bac6c5d96ccf90eb16e32"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>valence</b> (<a class="el" href="classpmp_1_1_face.html">Face</a> f) const</td></tr>
<tr class="memdesc:ab0176af2f62bac6c5d96ccf90eb16e32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the valence of face <code>f</code> (its number of vertices). <br /></td></tr>
<tr class="separator:ab0176af2f62bac6c5d96ccf90eb16e32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6ff8850e913051c410ffb5633db4c0b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#ae6ff8850e913051c410ffb5633db4c0b">delete_vertex</a> (<a class="el" href="classpmp_1_1_vertex.html">Vertex</a> v)</td></tr>
<tr class="memdesc:ae6ff8850e913051c410ffb5633db4c0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete vertex <code>v</code> from the mesh.  <br /></td></tr>
<tr class="separator:ae6ff8850e913051c410ffb5633db4c0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe4849293503a75788245bd75448bf5c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#abe4849293503a75788245bd75448bf5c">delete_edge</a> (<a class="el" href="classpmp_1_1_edge.html">Edge</a> e)</td></tr>
<tr class="memdesc:abe4849293503a75788245bd75448bf5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete edge <code>e</code> from the mesh.  <br /></td></tr>
<tr class="separator:abe4849293503a75788245bd75448bf5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32deae6d90a3de44d52526546e62bda3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#a32deae6d90a3de44d52526546e62bda3">delete_face</a> (<a class="el" href="classpmp_1_1_face.html">Face</a> f)</td></tr>
<tr class="memdesc:a32deae6d90a3de44d52526546e62bda3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes face <code>f</code> from the mesh.  <br /></td></tr>
<tr class="separator:a32deae6d90a3de44d52526546e62bda3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Geometry-related Functions</div></td></tr>
<tr class="memitem:a94c0dfb2c70e917928cdbfba0a943591"><td class="memItemLeft" align="right" valign="top"><a id="a94c0dfb2c70e917928cdbfba0a943591" name="a94c0dfb2c70e917928cdbfba0a943591"></a>
const <a class="el" href="group__core.html#ga4fc38b084567aed726be776958bfcc78">Point</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>position</b> (<a class="el" href="classpmp_1_1_vertex.html">Vertex</a> v) const</td></tr>
<tr class="memdesc:a94c0dfb2c70e917928cdbfba0a943591"><td class="mdescLeft">&#160;</td><td class="mdescRight">position of a vertex (read only) <br /></td></tr>
<tr class="separator:a94c0dfb2c70e917928cdbfba0a943591"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f90eddd7740ce3d94c36a528231ede1"><td class="memItemLeft" align="right" valign="top"><a id="a2f90eddd7740ce3d94c36a528231ede1" name="a2f90eddd7740ce3d94c36a528231ede1"></a>
<a class="el" href="group__core.html#ga4fc38b084567aed726be776958bfcc78">Point</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>position</b> (<a class="el" href="classpmp_1_1_vertex.html">Vertex</a> v)</td></tr>
<tr class="memdesc:a2f90eddd7740ce3d94c36a528231ede1"><td class="mdescLeft">&#160;</td><td class="mdescRight">position of a vertex <br /></td></tr>
<tr class="separator:a2f90eddd7740ce3d94c36a528231ede1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e02108cce3438fb23485f5309b6dd00"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="group__core.html#ga4fc38b084567aed726be776958bfcc78">Point</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#a9e02108cce3438fb23485f5309b6dd00">positions</a> ()</td></tr>
<tr class="separator:a9e02108cce3438fb23485f5309b6dd00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Allocate new elements</div></td></tr>
<tr class="memitem:a58cd90c6291c87ba918f4d9591ffb839"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmp_1_1_vertex.html">Vertex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#a58cd90c6291c87ba918f4d9591ffb839">new_vertex</a> ()</td></tr>
<tr class="memdesc:a58cd90c6291c87ba918f4d9591ffb839"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a new vertex, resize vertex properties accordingly.  <br /></td></tr>
<tr class="separator:a58cd90c6291c87ba918f4d9591ffb839"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4054f25d529880a07dee0c14d8ee4d82"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmp_1_1_halfedge.html">Halfedge</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#a4054f25d529880a07dee0c14d8ee4d82">new_edge</a> ()</td></tr>
<tr class="memdesc:a4054f25d529880a07dee0c14d8ee4d82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a new edge, resize edge and halfedge properties accordingly.  <br /></td></tr>
<tr class="separator:a4054f25d529880a07dee0c14d8ee4d82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b79e71b6c2d01e7b0987319c6564f0c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmp_1_1_halfedge.html">Halfedge</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#a1b79e71b6c2d01e7b0987319c6564f0c">new_edge</a> (<a class="el" href="classpmp_1_1_vertex.html">Vertex</a> start, <a class="el" href="classpmp_1_1_vertex.html">Vertex</a> end)</td></tr>
<tr class="memdesc:a1b79e71b6c2d01e7b0987319c6564f0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a new edge, resize edge and halfedge properties accordingly.  <br /></td></tr>
<tr class="separator:a1b79e71b6c2d01e7b0987319c6564f0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf32bb2f51669546e4d6ee9968c10042"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmp_1_1_face.html">Face</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#adf32bb2f51669546e4d6ee9968c10042">new_face</a> ()</td></tr>
<tr class="memdesc:adf32bb2f51669546e4d6ee9968c10042"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a new face, resize face properties accordingly.  <br /></td></tr>
<tr class="separator:adf32bb2f51669546e4d6ee9968c10042"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A class for representing polygon surface meshes. </p>
<p>This class implements a half-edge data structure for surface meshes. See <a class="el" href="citelist.html#CITEREF_sieger_2011_design">[21]</a> for details on the design and implementation. </p><dl class="section note"><dt>Note</dt><dd>This class only supports 2-manifold surface meshes with boundary. </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a56b36b29abcd020e3096c41c7f45ce1c" name="a56b36b29abcd020e3096c41c7f45ce1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56b36b29abcd020e3096c41c7f45ce1c">&#9670;&#160;</a></span>SurfaceMesh()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmp_1_1_surface_mesh.html">SurfaceMesh</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpmp_1_1_surface_mesh.html">SurfaceMesh</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>copy constructor: copies <code>rhs</code> to <code>*this</code>. </p>
<p>performs a deep copy of all properties. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="adc951d12a195401ac66e813fde413438" name="adc951d12a195401ac66e813fde413438"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc951d12a195401ac66e813fde413438">&#9670;&#160;</a></span>add_edge_property()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmp_1_1_edge_property.html">EdgeProperty</a>&lt; T &gt; add_edge_property </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>t</em> = <code>T()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>add a edge property of type <code>T</code> with name <code>name</code> and default value <code>t</code>. </p>
<p>fails if a property named <code>name</code> exists already, since the name has to be unique. in this case it returns an invalid property. </p>

</div>
</div>
<a id="ab50547b83aff7a33ae6a534a6d7795ca" name="ab50547b83aff7a33ae6a534a6d7795ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab50547b83aff7a33ae6a534a6d7795ca">&#9670;&#160;</a></span>add_face()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmp_1_1_face.html">Face</a> add_face </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classpmp_1_1_vertex.html">Vertex</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vertices</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a new face with vertex list <code>vertices</code>. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmp_1_1_topology_exception.html" title="Exception indicating a topological error has occurred.">TopologyException</a></td><td>in case a topological error occurs. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classpmp_1_1_surface_mesh.html#ae6a0d31259cf4eacc096bc100bd6dbe5" title="add a new triangle connecting vertices v0, v1, v2">add_triangle</a>, <a class="el" href="classpmp_1_1_surface_mesh.html#a6e6fb0718623ced3782e800e67badac5" title="add a new quad connecting vertices v0, v1, v2, v3">add_quad</a> </dd></dl>

</div>
</div>
<a id="a9703ad1a174de89c27fe185153b456d5" name="a9703ad1a174de89c27fe185153b456d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9703ad1a174de89c27fe185153b456d5">&#9670;&#160;</a></span>add_face_property()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmp_1_1_face_property.html">FaceProperty</a>&lt; T &gt; add_face_property </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>t</em> = <code>T()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>add a face property of type <code>T</code> with name <code>name</code> and default value <code>t</code>. </p>
<p>fails if a property named <code>name</code> exists already, since the name has to be unique. in this case it returns an invalid property </p>

</div>
</div>
<a id="a21fcc50b5371ceede90be575f33c35a7" name="a21fcc50b5371ceede90be575f33c35a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21fcc50b5371ceede90be575f33c35a7">&#9670;&#160;</a></span>add_halfedge_property()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmp_1_1_halfedge_property.html">HalfedgeProperty</a>&lt; T &gt; add_halfedge_property </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>t</em> = <code>T()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>add a halfedge property of type <code>T</code> with name <code>name</code> and default value <code>t</code>. </p>
<p>fails if a property named <code>name</code> exists already, since the name has to be unique. in this case it returns an invalid property. </p>

</div>
</div>
<a id="a6e6fb0718623ced3782e800e67badac5" name="a6e6fb0718623ced3782e800e67badac5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e6fb0718623ced3782e800e67badac5">&#9670;&#160;</a></span>add_quad()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmp_1_1_face.html">Face</a> add_quad </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmp_1_1_vertex.html">Vertex</a>&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpmp_1_1_vertex.html">Vertex</a>&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpmp_1_1_vertex.html">Vertex</a>&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpmp_1_1_vertex.html">Vertex</a>&#160;</td>
          <td class="paramname"><em>v3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>add a new quad connecting vertices <code>v0</code>, <code>v1</code>, <code>v2</code>, <code>v3</code> </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classpmp_1_1_surface_mesh.html#ae6a0d31259cf4eacc096bc100bd6dbe5" title="add a new triangle connecting vertices v0, v1, v2">add_triangle</a>, <a class="el" href="classpmp_1_1_surface_mesh.html#ab50547b83aff7a33ae6a534a6d7795ca" title="Add a new face with vertex list vertices.">add_face</a> </dd></dl>

</div>
</div>
<a id="ae6a0d31259cf4eacc096bc100bd6dbe5" name="ae6a0d31259cf4eacc096bc100bd6dbe5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6a0d31259cf4eacc096bc100bd6dbe5">&#9670;&#160;</a></span>add_triangle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmp_1_1_face.html">Face</a> add_triangle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmp_1_1_vertex.html">Vertex</a>&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpmp_1_1_vertex.html">Vertex</a>&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpmp_1_1_vertex.html">Vertex</a>&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>add a new triangle connecting vertices <code>v0</code>, <code>v1</code>, <code>v2</code> </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classpmp_1_1_surface_mesh.html#ab50547b83aff7a33ae6a534a6d7795ca" title="Add a new face with vertex list vertices.">add_face</a>, <a class="el" href="classpmp_1_1_surface_mesh.html#a6e6fb0718623ced3782e800e67badac5" title="add a new quad connecting vertices v0, v1, v2, v3">add_quad</a> </dd></dl>

</div>
</div>
<a id="a901e73ce0a53ab3c3dd0067501556996" name="a901e73ce0a53ab3c3dd0067501556996"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a901e73ce0a53ab3c3dd0067501556996">&#9670;&#160;</a></span>add_vertex_property()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmp_1_1_vertex_property.html">VertexProperty</a>&lt; T &gt; add_vertex_property </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>t</em> = <code>T()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>add a vertex property of type <code>T</code> with name <code>name</code> and default value <code>t</code>. </p>
<p>fails if a property named <code>name</code> exists already, since the name has to be unique. in this case it returns an invalid property </p>

</div>
</div>
<a id="a588e0f69d96bd584043546cfd5e7fdc0" name="a588e0f69d96bd584043546cfd5e7fdc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a588e0f69d96bd584043546cfd5e7fdc0">&#9670;&#160;</a></span>ccw_rotated_halfedge()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmp_1_1_halfedge.html">Halfedge</a> ccw_rotated_halfedge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmp_1_1_halfedge.html">Halfedge</a>&#160;</td>
          <td class="paramname"><em>h</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the halfedge that is rotated counter-clockwise around the start vertex of <code>h</code>. it is the opposite halfedge of the previous halfedge of <code>h</code>. </dd></dl>

</div>
</div>
<a id="ac5f0d7874e4fe8878e44fd56ad7d3b23" name="ac5f0d7874e4fe8878e44fd56ad7d3b23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5f0d7874e4fe8878e44fd56ad7d3b23">&#9670;&#160;</a></span>collapse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void collapse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmp_1_1_halfedge.html">Halfedge</a>&#160;</td>
          <td class="paramname"><em>h</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collapse the halfedge <code>h</code> by moving its start vertex into its target vertex. </p>
<p>For non-boundary halfedges this function removes one vertex, three edges, and two faces. For boundary halfedges it removes one vertex, two edges and one face. </p><dl class="section attention"><dt>Attention</dt><dd>This function is only valid for triangle meshes. </dd>
<dd>
<a class="el" href="classpmp_1_1_halfedge.html" title="this type represents a halfedge (internally it is basically an index)">Halfedge</a> collapses might lead to invalid faces. Call is_collapse_ok(Halfedge) to be sure the collapse is legal. </dd>
<dd>
The removed items are only marked as deleted. You have to call <a class="el" href="classpmp_1_1_surface_mesh.html#a18ccfc2210e9d09621859d6f95381aaf" title="remove deleted elements">garbage_collection()</a> to finally remove them. </dd></dl>

</div>
</div>
<a id="adf30244b0452c72345b969428ea77d9d" name="adf30244b0452c72345b969428ea77d9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf30244b0452c72345b969428ea77d9d">&#9670;&#160;</a></span>cw_rotated_halfedge()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmp_1_1_halfedge.html">Halfedge</a> cw_rotated_halfedge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmp_1_1_halfedge.html">Halfedge</a>&#160;</td>
          <td class="paramname"><em>h</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the halfedge that is rotated clockwise around the start vertex of <code>h</code>. it is the next halfedge of the opposite halfedge of <code>h</code>. </dd></dl>

</div>
</div>
<a id="abe4849293503a75788245bd75448bf5c" name="abe4849293503a75788245bd75448bf5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe4849293503a75788245bd75448bf5c">&#9670;&#160;</a></span>delete_edge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void delete_edge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmp_1_1_edge.html">Edge</a>&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete edge <code>e</code> from the mesh. </p>
<dl class="section note"><dt>Note</dt><dd>Only marks the edge as deleted. Call <a class="el" href="classpmp_1_1_surface_mesh.html#a18ccfc2210e9d09621859d6f95381aaf" title="remove deleted elements">garbage_collection()</a> to finally remove deleted entities. </dd></dl>

</div>
</div>
<a id="a32deae6d90a3de44d52526546e62bda3" name="a32deae6d90a3de44d52526546e62bda3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32deae6d90a3de44d52526546e62bda3">&#9670;&#160;</a></span>delete_face()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void delete_face </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmp_1_1_face.html">Face</a>&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deletes face <code>f</code> from the mesh. </p>
<dl class="section note"><dt>Note</dt><dd>Only marks the face as deleted. Call <a class="el" href="classpmp_1_1_surface_mesh.html#a18ccfc2210e9d09621859d6f95381aaf" title="remove deleted elements">garbage_collection()</a> to finally remove deleted entities. </dd></dl>

</div>
</div>
<a id="ae6ff8850e913051c410ffb5633db4c0b" name="ae6ff8850e913051c410ffb5633db4c0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6ff8850e913051c410ffb5633db4c0b">&#9670;&#160;</a></span>delete_vertex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void delete_vertex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmp_1_1_vertex.html">Vertex</a>&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete vertex <code>v</code> from the mesh. </p>
<dl class="section note"><dt>Note</dt><dd>Only marks the vertex as deleted. Call <a class="el" href="classpmp_1_1_surface_mesh.html#a18ccfc2210e9d09621859d6f95381aaf" title="remove deleted elements">garbage_collection()</a> to finally remove deleted entities. </dd></dl>

</div>
</div>
<a id="ad458db917bf85de7ac73bc17808daa14" name="ad458db917bf85de7ac73bc17808daa14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad458db917bf85de7ac73bc17808daa14">&#9670;&#160;</a></span>edge()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmp_1_1_edge.html">Edge</a> edge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmp_1_1_halfedge.html">Halfedge</a>&#160;</td>
          <td class="paramname"><em>h</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the edge that contains halfedge <code>h</code> as one of its two halfedges. </dd></dl>

</div>
</div>
<a id="a6bd4a8d297474575c2089ccae456d31a" name="a6bd4a8d297474575c2089ccae456d31a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bd4a8d297474575c2089ccae456d31a">&#9670;&#160;</a></span>edge_properties()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; edge_properties </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the names of all edge properties </dd></dl>

</div>
</div>
<a id="ab72c709f83f75c767b2c48727f2db619" name="ab72c709f83f75c767b2c48727f2db619"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab72c709f83f75c767b2c48727f2db619">&#9670;&#160;</a></span>edge_property()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmp_1_1_edge_property.html">EdgeProperty</a>&lt; T &gt; edge_property </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>t</em> = <code>T()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>if an edge property of type <code>T</code> with name <code>name</code> exists, it is returned. </p>
<p>otherwise this property is added (with default value <code>t</code>) </p>

</div>
</div>
<a id="a0badaef8b3f0fab59125eedb12e5556e" name="a0badaef8b3f0fab59125eedb12e5556e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0badaef8b3f0fab59125eedb12e5556e">&#9670;&#160;</a></span>edges() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmp_1_1_surface_mesh_1_1_edge_container.html">EdgeContainer</a> edges </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>edge container for C++11 range-based for-loops </dd></dl>

</div>
</div>
<a id="a182905105e2b83d232bbcacf0430b946" name="a182905105e2b83d232bbcacf0430b946"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a182905105e2b83d232bbcacf0430b946">&#9670;&#160;</a></span>edges() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmp_1_1_surface_mesh_1_1_edge_around_vertex_circulator.html">EdgeAroundVertexCirculator</a> edges </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmp_1_1_vertex.html">Vertex</a>&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>circulator for edges around vertex <code>v</code> </dd></dl>

</div>
</div>
<a id="a5b369fd79dede60706600e60b4788fc9" name="a5b369fd79dede60706600e60b4788fc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b369fd79dede60706600e60b4788fc9">&#9670;&#160;</a></span>edges_begin()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmp_1_1_surface_mesh_1_1_edge_iterator.html">EdgeIterator</a> edges_begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>start iterator for edges </dd></dl>

</div>
</div>
<a id="a155a6587f1e778e8a7756b066965369d" name="a155a6587f1e778e8a7756b066965369d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a155a6587f1e778e8a7756b066965369d">&#9670;&#160;</a></span>edges_end()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmp_1_1_surface_mesh_1_1_edge_iterator.html">EdgeIterator</a> edges_end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>end iterator for edges </dd></dl>

</div>
</div>
<a id="a60e4af817e3a9bb25ce627275411717a" name="a60e4af817e3a9bb25ce627275411717a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60e4af817e3a9bb25ce627275411717a">&#9670;&#160;</a></span>edges_size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t edges_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>number of (deleted and valid) edges in the mesh </dd></dl>

</div>
</div>
<a id="ae5c4d6fe9f6984ff83ee80b05d1208ed" name="ae5c4d6fe9f6984ff83ee80b05d1208ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5c4d6fe9f6984ff83ee80b05d1208ed">&#9670;&#160;</a></span>face() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmp_1_1_face.html">Face</a> face </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmp_1_1_edge.html">Edge</a>&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the face incident to the <code>i'th</code> halfedge of edge <code>e</code>. <code>i</code> has to be 0 or 1. </dd></dl>

</div>
</div>
<a id="ab89ca2f5a06d4216412f355cb234311d" name="ab89ca2f5a06d4216412f355cb234311d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab89ca2f5a06d4216412f355cb234311d">&#9670;&#160;</a></span>face() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmp_1_1_face.html">Face</a> face </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmp_1_1_halfedge.html">Halfedge</a>&#160;</td>
          <td class="paramname"><em>h</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the face incident to halfedge <code>h</code> </dd></dl>

</div>
</div>
<a id="a4b190ab20c7ad53b7892747f9f3e5f56" name="a4b190ab20c7ad53b7892747f9f3e5f56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b190ab20c7ad53b7892747f9f3e5f56">&#9670;&#160;</a></span>face_properties()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; face_properties </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the names of all face properties </dd></dl>

</div>
</div>
<a id="a94dfa3b6c130d2d2689c0fc55bc73419" name="a94dfa3b6c130d2d2689c0fc55bc73419"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94dfa3b6c130d2d2689c0fc55bc73419">&#9670;&#160;</a></span>face_property()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmp_1_1_face_property.html">FaceProperty</a>&lt; T &gt; face_property </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>t</em> = <code>T()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>if a face property of type <code>T</code> with name <code>name</code> exists, it is returned. </p>
<p>otherwise this property is added (with default value <code>t</code>) </p>

</div>
</div>
<a id="a50c0bab596df80894c1c694912193a5f" name="a50c0bab596df80894c1c694912193a5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50c0bab596df80894c1c694912193a5f">&#9670;&#160;</a></span>faces() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmp_1_1_surface_mesh_1_1_face_container.html">FaceContainer</a> faces </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>face container for C++11 range-based for-loops </dd></dl>

</div>
</div>
<a id="a972e42a9966f5ce484a5364fc6f0a0f0" name="a972e42a9966f5ce484a5364fc6f0a0f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a972e42a9966f5ce484a5364fc6f0a0f0">&#9670;&#160;</a></span>faces() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmp_1_1_surface_mesh_1_1_face_around_vertex_circulator.html">FaceAroundVertexCirculator</a> faces </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmp_1_1_vertex.html">Vertex</a>&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>circulator for faces around vertex <code>v</code> </dd></dl>

</div>
</div>
<a id="a5f8263f0242eb7044ea5028d80ddb773" name="a5f8263f0242eb7044ea5028d80ddb773"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f8263f0242eb7044ea5028d80ddb773">&#9670;&#160;</a></span>faces_begin()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmp_1_1_surface_mesh_1_1_face_iterator.html">FaceIterator</a> faces_begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>start iterator for faces </dd></dl>

</div>
</div>
<a id="abf78c04ead850dd21d04703d5450f005" name="abf78c04ead850dd21d04703d5450f005"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf78c04ead850dd21d04703d5450f005">&#9670;&#160;</a></span>faces_end()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmp_1_1_surface_mesh_1_1_face_iterator.html">FaceIterator</a> faces_end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>end iterator for faces </dd></dl>

</div>
</div>
<a id="a045df1c7493495e832c01974f6bc01d6" name="a045df1c7493495e832c01974f6bc01d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a045df1c7493495e832c01974f6bc01d6">&#9670;&#160;</a></span>faces_size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t faces_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>number of (deleted and valid) faces in the mesh </dd></dl>

</div>
</div>
<a id="ac689cb1b5d5c7e2ab309c15e1388349a" name="ac689cb1b5d5c7e2ab309c15e1388349a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac689cb1b5d5c7e2ab309c15e1388349a">&#9670;&#160;</a></span>flip()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void flip </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmp_1_1_edge.html">Edge</a>&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flip the edge <code>e</code> . </p>
<p>Removes the edge <code>e</code> and add an edge between the two vertices opposite to edge <code>e</code> of the two incident triangles. </p><dl class="section attention"><dt>Attention</dt><dd>This function is only valid for triangle meshes. </dd>
<dd>
Flipping an edge may result in a non-manifold mesh, hence check for yourself whether this operation is allowed or not! </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classpmp_1_1_surface_mesh.html#a4d7b1645c59f855683a01a8f1b87e6da" title="Check whether flipping edge e is topologically OK.">is_flip_ok()</a> </dd></dl>

</div>
</div>
<a id="a55e2ad655b34779a1a18411c0df56580" name="a55e2ad655b34779a1a18411c0df56580"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55e2ad655b34779a1a18411c0df56580">&#9670;&#160;</a></span>from_vertex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmp_1_1_vertex.html">Vertex</a> from_vertex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmp_1_1_halfedge.html">Halfedge</a>&#160;</td>
          <td class="paramname"><em>h</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the vertex the halfedge <code>h</code> emanates from </dd></dl>

</div>
</div>
<a id="a574931d8d9df34ff1b54351131f41bad" name="a574931d8d9df34ff1b54351131f41bad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a574931d8d9df34ff1b54351131f41bad">&#9670;&#160;</a></span>get_edge_property()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmp_1_1_edge_property.html">EdgeProperty</a>&lt; T &gt; get_edge_property </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get the edge property named <code>name</code> of type <code>T</code>. </p>
<p>returns an invalid <a class="el" href="classpmp_1_1_vertex_property.html" title="Vertex property of type T.">VertexProperty</a> if the property does not exist or if the type does not match. </p>

</div>
</div>
<a id="a2fe9e716e46c8ed83fa1c9891aab71bd" name="a2fe9e716e46c8ed83fa1c9891aab71bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fe9e716e46c8ed83fa1c9891aab71bd">&#9670;&#160;</a></span>get_face_property()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmp_1_1_face_property.html">FaceProperty</a>&lt; T &gt; get_face_property </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get the face property named <code>name</code> of type <code>T</code>. </p>
<p>returns an invalid <a class="el" href="classpmp_1_1_vertex_property.html" title="Vertex property of type T.">VertexProperty</a> if the property does not exist or if the type does not match. </p>

</div>
</div>
<a id="aabbb1cfa4ad230b4dd6677f480763d5b" name="aabbb1cfa4ad230b4dd6677f480763d5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabbb1cfa4ad230b4dd6677f480763d5b">&#9670;&#160;</a></span>get_halfedge_property()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmp_1_1_halfedge_property.html">HalfedgeProperty</a>&lt; T &gt; get_halfedge_property </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get the halfedge property named <code>name</code> of type <code>T</code>. </p>
<p>returns an invalid <a class="el" href="classpmp_1_1_vertex_property.html" title="Vertex property of type T.">VertexProperty</a> if the property does not exist or if the type does not match. </p>

</div>
</div>
<a id="a617c33083979c72bacd5fc6c798179cb" name="a617c33083979c72bacd5fc6c798179cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a617c33083979c72bacd5fc6c798179cb">&#9670;&#160;</a></span>get_vertex_property()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmp_1_1_vertex_property.html">VertexProperty</a>&lt; T &gt; get_vertex_property </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get the vertex property named <code>name</code> of type <code>T</code>. </p>
<p>returns an invalid <a class="el" href="classpmp_1_1_vertex_property.html" title="Vertex property of type T.">VertexProperty</a> if the property does not exist or if the type does not match. </p>

</div>
</div>
<a id="a3cc004bd087fc53cf1b3386269578688" name="a3cc004bd087fc53cf1b3386269578688"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cc004bd087fc53cf1b3386269578688">&#9670;&#160;</a></span>halfedge() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmp_1_1_halfedge.html">Halfedge</a> halfedge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmp_1_1_edge.html">Edge</a>&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the <code>i'th</code> halfedge of edge <code>e</code>. <code>i</code> has to be 0 or 1. </dd></dl>

</div>
</div>
<a id="a72dd99a11016012e1afaed4b581a4f64" name="a72dd99a11016012e1afaed4b581a4f64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72dd99a11016012e1afaed4b581a4f64">&#9670;&#160;</a></span>halfedge() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmp_1_1_halfedge.html">Halfedge</a> halfedge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmp_1_1_face.html">Face</a>&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a halfedge of face <code>f</code> </dd></dl>

</div>
</div>
<a id="af6bce4e4a93c05a02be9ca8dd842de43" name="af6bce4e4a93c05a02be9ca8dd842de43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6bce4e4a93c05a02be9ca8dd842de43">&#9670;&#160;</a></span>halfedge() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmp_1_1_halfedge.html">Halfedge</a> halfedge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmp_1_1_vertex.html">Vertex</a>&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an outgoing halfedge of vertex <code>v</code>. if <code>v</code> is a boundary vertex this will be a boundary halfedge. </dd></dl>

</div>
</div>
<a id="a9a714ffe7af34bd510864ba3586acabc" name="a9a714ffe7af34bd510864ba3586acabc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a714ffe7af34bd510864ba3586acabc">&#9670;&#160;</a></span>halfedge_properties()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; halfedge_properties </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the names of all halfedge properties </dd></dl>

</div>
</div>
<a id="ac7f9114394d2d9f129fe510f0548bc8d" name="ac7f9114394d2d9f129fe510f0548bc8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7f9114394d2d9f129fe510f0548bc8d">&#9670;&#160;</a></span>halfedge_property()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmp_1_1_halfedge_property.html">HalfedgeProperty</a>&lt; T &gt; halfedge_property </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>t</em> = <code>T()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>if a halfedge property of type <code>T</code> with name <code>name</code> exists, it is returned. </p>
<p>otherwise this property is added (with default value <code>t</code>) </p>

</div>
</div>
<a id="a74a649abba6e8f2ff77d4a56c36eecc1" name="a74a649abba6e8f2ff77d4a56c36eecc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74a649abba6e8f2ff77d4a56c36eecc1">&#9670;&#160;</a></span>halfedges() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmp_1_1_surface_mesh_1_1_halfedge_container.html">HalfedgeContainer</a> halfedges </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>halfedge container for C++11 range-based for-loops </dd></dl>

</div>
</div>
<a id="a1b441eb9b6cad9459f68afe6265e72ed" name="a1b441eb9b6cad9459f68afe6265e72ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b441eb9b6cad9459f68afe6265e72ed">&#9670;&#160;</a></span>halfedges() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmp_1_1_surface_mesh_1_1_halfedge_around_face_circulator.html">HalfedgeAroundFaceCirculator</a> halfedges </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmp_1_1_face.html">Face</a>&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>circulator for halfedges of face <code>f</code> </dd></dl>

</div>
</div>
<a id="ad2e6e4cb42864442169e18bc1fbb8827" name="ad2e6e4cb42864442169e18bc1fbb8827"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2e6e4cb42864442169e18bc1fbb8827">&#9670;&#160;</a></span>halfedges() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmp_1_1_surface_mesh_1_1_halfedge_around_vertex_circulator.html">HalfedgeAroundVertexCirculator</a> halfedges </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmp_1_1_vertex.html">Vertex</a>&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>circulator for outgoing halfedges around vertex <code>v</code> </dd></dl>

</div>
</div>
<a id="aa7c6741949eb649d31a524fe78aa21bf" name="aa7c6741949eb649d31a524fe78aa21bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7c6741949eb649d31a524fe78aa21bf">&#9670;&#160;</a></span>halfedges_begin()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmp_1_1_surface_mesh_1_1_halfedge_iterator.html">HalfedgeIterator</a> halfedges_begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>start iterator for halfedges </dd></dl>

</div>
</div>
<a id="ae958f4ac33e405602a5bb138992e99fa" name="ae958f4ac33e405602a5bb138992e99fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae958f4ac33e405602a5bb138992e99fa">&#9670;&#160;</a></span>halfedges_end()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmp_1_1_surface_mesh_1_1_halfedge_iterator.html">HalfedgeIterator</a> halfedges_end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>end iterator for halfedges </dd></dl>

</div>
</div>
<a id="ab6f6842a96aab68705bae800bea3eae8" name="ab6f6842a96aab68705bae800bea3eae8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6f6842a96aab68705bae800bea3eae8">&#9670;&#160;</a></span>halfedges_size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t halfedges_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>number of (deleted and valid) halfedges in the mesh </dd></dl>

</div>
</div>
<a id="a7ded6c774cb197b607f23bba25aa876a" name="a7ded6c774cb197b607f23bba25aa876a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ded6c774cb197b607f23bba25aa876a">&#9670;&#160;</a></span>insert_edge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmp_1_1_halfedge.html">Halfedge</a> insert_edge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmp_1_1_halfedge.html">Halfedge</a>&#160;</td>
          <td class="paramname"><em>h0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpmp_1_1_halfedge.html">Halfedge</a>&#160;</td>
          <td class="paramname"><em>h1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert edge between the to-vertices of <code>h0</code> and <code>h1</code>. </p>
<dl class="section return"><dt>Returns</dt><dd>The new halfedge from v0 to v1. </dd></dl>
<dl class="section attention"><dt>Attention</dt><dd><code>h0</code> and <code>h1</code> have to belong to the same face. </dd></dl>

</div>
</div>
<a id="a8ee3d85c54f6a3b34678b94847e557ed" name="a8ee3d85c54f6a3b34678b94847e557ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ee3d85c54f6a3b34678b94847e557ed">&#9670;&#160;</a></span>insert_vertex() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmp_1_1_halfedge.html">Halfedge</a> insert_vertex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmp_1_1_edge.html">Edge</a>&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__core.html#ga4fc38b084567aed726be776958bfcc78">Point</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subdivide the edge <code>e</code> = (v0,v1) by splitting it into the two edge (v0,p) and (p,v1). </p>
<p>Note that this function does not introduce any other edge or faces. It simply splits the edge. Returns halfedge that points to <code>p</code>. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classpmp_1_1_surface_mesh.html#a3fdde5d6bfaac76a7dafb9c7fb1b01bd" title="Subdivide the edge e = (v0,v1) by splitting it into the two edge (v0,v) and (v,v1).">insert_vertex(Edge, Vertex)</a> </dd>
<dd>
<a class="el" href="classpmp_1_1_surface_mesh.html#a36b01ea47ba079cb27b784fd6c8341d8" title="Subdivide the halfedge h = (v0,v1) by splitting it into the two halfedges (v0,v) and (v,...">insert_vertex(Halfedge, Vertex)</a> </dd></dl>

</div>
</div>
<a id="a3fdde5d6bfaac76a7dafb9c7fb1b01bd" name="a3fdde5d6bfaac76a7dafb9c7fb1b01bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fdde5d6bfaac76a7dafb9c7fb1b01bd">&#9670;&#160;</a></span>insert_vertex() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmp_1_1_halfedge.html">Halfedge</a> insert_vertex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmp_1_1_edge.html">Edge</a>&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpmp_1_1_vertex.html">Vertex</a>&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subdivide the edge <code>e</code> = (v0,v1) by splitting it into the two edge (v0,v) and (v,v1). </p>
<p>Note that this function does not introduce any other edge or faces. It simply splits the edge. Returns halfedge that points to <code>p</code>. </p><dl class="section see"><dt>See also</dt><dd>insert_vertex(Edge, Point) </dd>
<dd>
<a class="el" href="classpmp_1_1_surface_mesh.html#a36b01ea47ba079cb27b784fd6c8341d8" title="Subdivide the halfedge h = (v0,v1) by splitting it into the two halfedges (v0,v) and (v,...">insert_vertex(Halfedge, Vertex)</a> </dd></dl>

</div>
</div>
<a id="a36b01ea47ba079cb27b784fd6c8341d8" name="a36b01ea47ba079cb27b784fd6c8341d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36b01ea47ba079cb27b784fd6c8341d8">&#9670;&#160;</a></span>insert_vertex() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmp_1_1_halfedge.html">Halfedge</a> insert_vertex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmp_1_1_halfedge.html">Halfedge</a>&#160;</td>
          <td class="paramname"><em>h0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpmp_1_1_vertex.html">Vertex</a>&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Subdivide the halfedge <code>h</code> = (v0,v1) by splitting it into the two halfedges (v0,v) and (v,v1). </p>
<p>Note that this function does not introduce any other edge or faces. It simply splits the edge. Returns the halfedge that points from v1 to <code>v</code>. </p><dl class="section see"><dt>See also</dt><dd>insert_vertex(Edge, Point) </dd>
<dd>
<a class="el" href="classpmp_1_1_surface_mesh.html#a3fdde5d6bfaac76a7dafb9c7fb1b01bd" title="Subdivide the edge e = (v0,v1) by splitting it into the two edge (v0,v) and (v,v1).">insert_vertex(Edge, Vertex)</a> </dd></dl>

</div>
</div>
<a id="a5d473cb489519535b6812172305e1b7f" name="a5d473cb489519535b6812172305e1b7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d473cb489519535b6812172305e1b7f">&#9670;&#160;</a></span>is_boundary() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool is_boundary </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmp_1_1_edge.html">Edge</a>&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>whether <code>e</code> is a boundary edge, i.e., if one of its halfedges is a boundary halfedge. </dd></dl>

</div>
</div>
<a id="acaf1a18244ce7378e3b1198dccc7c032" name="acaf1a18244ce7378e3b1198dccc7c032"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acaf1a18244ce7378e3b1198dccc7c032">&#9670;&#160;</a></span>is_boundary() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool is_boundary </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmp_1_1_face.html">Face</a>&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>whether <code>f</code> is a boundary face, i.e., it one of its edges is a boundary edge. </dd></dl>

</div>
</div>
<a id="adb749d4b88b89e5693809cbbc5ed015d" name="adb749d4b88b89e5693809cbbc5ed015d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb749d4b88b89e5693809cbbc5ed015d">&#9670;&#160;</a></span>is_boundary() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool is_boundary </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmp_1_1_halfedge.html">Halfedge</a>&#160;</td>
          <td class="paramname"><em>h</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>whether h is a boundary halfedge, i.e., if its face does not exist. </dd></dl>

</div>
</div>
<a id="acc14569aa72d62aa569d3ef31053420d" name="acc14569aa72d62aa569d3ef31053420d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc14569aa72d62aa569d3ef31053420d">&#9670;&#160;</a></span>is_boundary() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool is_boundary </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmp_1_1_vertex.html">Vertex</a>&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>whether <code>v</code> is a boundary vertex </dd></dl>

</div>
</div>
<a id="a6ec6d4a3b869975acb3e749bacd54e12" name="a6ec6d4a3b869975acb3e749bacd54e12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ec6d4a3b869975acb3e749bacd54e12">&#9670;&#160;</a></span>is_collapse_ok()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool is_collapse_ok </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmp_1_1_halfedge.html">Halfedge</a>&#160;</td>
          <td class="paramname"><em>v0v1</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>whether collapsing the halfedge <code>v0v1</code> is topologically legal. </dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>This function is only valid for triangle meshes. </dd></dl>

</div>
</div>
<a id="a7b3401f7fc43215a63c78acdb1b4ed7c" name="a7b3401f7fc43215a63c78acdb1b4ed7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b3401f7fc43215a63c78acdb1b4ed7c">&#9670;&#160;</a></span>is_deleted() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool is_deleted </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmp_1_1_edge.html">Edge</a>&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>whether edge <code>e</code> is deleted </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classpmp_1_1_surface_mesh.html#a18ccfc2210e9d09621859d6f95381aaf" title="remove deleted elements">garbage_collection()</a> </dd></dl>

</div>
</div>
<a id="a737682e4d34e7d61aeb1105d3fd17626" name="a737682e4d34e7d61aeb1105d3fd17626"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a737682e4d34e7d61aeb1105d3fd17626">&#9670;&#160;</a></span>is_deleted() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool is_deleted </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmp_1_1_face.html">Face</a>&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>whether face <code>f</code> is deleted </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classpmp_1_1_surface_mesh.html#a18ccfc2210e9d09621859d6f95381aaf" title="remove deleted elements">garbage_collection()</a> </dd></dl>

</div>
</div>
<a id="ad254f6af02142634deb39fa5bbc65d39" name="ad254f6af02142634deb39fa5bbc65d39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad254f6af02142634deb39fa5bbc65d39">&#9670;&#160;</a></span>is_deleted() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool is_deleted </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmp_1_1_halfedge.html">Halfedge</a>&#160;</td>
          <td class="paramname"><em>h</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>whether halfedge <code>h</code> is deleted </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classpmp_1_1_surface_mesh.html#a18ccfc2210e9d09621859d6f95381aaf" title="remove deleted elements">garbage_collection()</a> </dd></dl>

</div>
</div>
<a id="a6e92fd7fbcb7f8d00a67b3a38d32dc43" name="a6e92fd7fbcb7f8d00a67b3a38d32dc43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e92fd7fbcb7f8d00a67b3a38d32dc43">&#9670;&#160;</a></span>is_deleted() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool is_deleted </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmp_1_1_vertex.html">Vertex</a>&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>whether vertex <code>v</code> is deleted </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classpmp_1_1_surface_mesh.html#a18ccfc2210e9d09621859d6f95381aaf" title="remove deleted elements">garbage_collection()</a> </dd></dl>

</div>
</div>
<a id="a5a2b7a58dc85678d08752945ff655362" name="a5a2b7a58dc85678d08752945ff655362"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a2b7a58dc85678d08752945ff655362">&#9670;&#160;</a></span>is_empty()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool is_empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if the mesh is empty, i.e., has no vertices </dd></dl>

</div>
</div>
<a id="a4d7b1645c59f855683a01a8f1b87e6da" name="a4d7b1645c59f855683a01a8f1b87e6da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d7b1645c59f855683a01a8f1b87e6da">&#9670;&#160;</a></span>is_flip_ok()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool is_flip_ok </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmp_1_1_edge.html">Edge</a>&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check whether flipping edge <code>e</code> is topologically OK. </p>
<dl class="section attention"><dt>Attention</dt><dd>This function is only valid for triangle meshes. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classpmp_1_1_surface_mesh.html#ac689cb1b5d5c7e2ab309c15e1388349a" title="Flip the edge e .">flip(Edge)</a> </dd></dl>

</div>
</div>
<a id="acf27870c55e439d315e7916dd92889d1" name="acf27870c55e439d315e7916dd92889d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf27870c55e439d315e7916dd92889d1">&#9670;&#160;</a></span>is_isolated()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool is_isolated </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmp_1_1_vertex.html">Vertex</a>&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>whether <code>v</code> is isolated, i.e., not incident to any edge </dd></dl>

</div>
</div>
<a id="ac88fa768c6dd4e545df7bb105cd3c1b7" name="ac88fa768c6dd4e545df7bb105cd3c1b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac88fa768c6dd4e545df7bb105cd3c1b7">&#9670;&#160;</a></span>is_manifold()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool is_manifold </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmp_1_1_vertex.html">Vertex</a>&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>whether <code>v</code> is a manifold vertex (not incident to several patches) </dd></dl>

</div>
</div>
<a id="a0a85b726b7fde45bfec81127fc85c042" name="a0a85b726b7fde45bfec81127fc85c042"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a85b726b7fde45bfec81127fc85c042">&#9670;&#160;</a></span>is_quad_mesh()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool is_quad_mesh </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>whether the mesh a quad mesh. this function simply tests each face, and therefore is not very efficient. </dd></dl>

</div>
</div>
<a id="a11eac1c73cdf1ff27e223fbce181e5a0" name="a11eac1c73cdf1ff27e223fbce181e5a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11eac1c73cdf1ff27e223fbce181e5a0">&#9670;&#160;</a></span>is_removal_ok()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool is_removal_ok </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmp_1_1_edge.html">Edge</a>&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>whether removing the edge <code>e</code> is topologically legal. </dd></dl>

</div>
</div>
<a id="a9cede937c41f63448522e8522f7d65a5" name="a9cede937c41f63448522e8522f7d65a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cede937c41f63448522e8522f7d65a5">&#9670;&#160;</a></span>is_triangle_mesh()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool is_triangle_mesh </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>whether the mesh a triangle mesh. this function simply tests each face, and therefore is not very efficient. </dd></dl>

</div>
</div>
<a id="a1ce65fa0b9a24e1ed45f5578f74016cd" name="a1ce65fa0b9a24e1ed45f5578f74016cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ce65fa0b9a24e1ed45f5578f74016cd">&#9670;&#160;</a></span>is_valid() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool is_valid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmp_1_1_edge.html">Edge</a>&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>whether edge <code>e</code> is valid. </dd></dl>

</div>
</div>
<a id="aad9d43c3b09e4dc9d004c8e2ac6fa3dd" name="aad9d43c3b09e4dc9d004c8e2ac6fa3dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad9d43c3b09e4dc9d004c8e2ac6fa3dd">&#9670;&#160;</a></span>is_valid() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool is_valid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmp_1_1_face.html">Face</a>&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>whether the face <code>f</code> is valid. </dd></dl>

</div>
</div>
<a id="a1ae05a79983cb96b5a739875fc602e3f" name="a1ae05a79983cb96b5a739875fc602e3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ae05a79983cb96b5a739875fc602e3f">&#9670;&#160;</a></span>is_valid() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool is_valid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmp_1_1_halfedge.html">Halfedge</a>&#160;</td>
          <td class="paramname"><em>h</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>whether halfedge <code>h</code> is valid. </dd></dl>

</div>
</div>
<a id="aec6665e506694c78cb4e33c629250eae" name="aec6665e506694c78cb4e33c629250eae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec6665e506694c78cb4e33c629250eae">&#9670;&#160;</a></span>is_valid() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool is_valid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmp_1_1_vertex.html">Vertex</a>&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>whether vertex <code>v</code> is valid. </dd></dl>

</div>
</div>
<a id="a08b03909e7ab3a1f72e089537ce353c6" name="a08b03909e7ab3a1f72e089537ce353c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08b03909e7ab3a1f72e089537ce353c6">&#9670;&#160;</a></span>n_edges()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t n_edges </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>number of edges in the mesh </dd></dl>

</div>
</div>
<a id="aa18b9618188508bc2c5bb0fd81625880" name="aa18b9618188508bc2c5bb0fd81625880"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa18b9618188508bc2c5bb0fd81625880">&#9670;&#160;</a></span>n_faces()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t n_faces </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>number of faces in the mesh </dd></dl>

</div>
</div>
<a id="a006d64c9b0755da0afd525e9fbe0573f" name="a006d64c9b0755da0afd525e9fbe0573f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a006d64c9b0755da0afd525e9fbe0573f">&#9670;&#160;</a></span>n_halfedges()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t n_halfedges </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>number of halfedge in the mesh </dd></dl>

</div>
</div>
<a id="a2538edd8437da799144eea8ba0a561f4" name="a2538edd8437da799144eea8ba0a561f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2538edd8437da799144eea8ba0a561f4">&#9670;&#160;</a></span>n_vertices()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t n_vertices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>number of vertices in the mesh </dd></dl>

</div>
</div>
<a id="a4054f25d529880a07dee0c14d8ee4d82" name="a4054f25d529880a07dee0c14d8ee4d82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4054f25d529880a07dee0c14d8ee4d82">&#9670;&#160;</a></span>new_edge() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmp_1_1_halfedge.html">Halfedge</a> new_edge </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocate a new edge, resize edge and halfedge properties accordingly. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmp_1_1_allocation_exception.html" title="Exception indicating failure to allocate a new resource.">AllocationException</a></td><td>in case of failure to allocate a new edge. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1b79e71b6c2d01e7b0987319c6564f0c" name="a1b79e71b6c2d01e7b0987319c6564f0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b79e71b6c2d01e7b0987319c6564f0c">&#9670;&#160;</a></span>new_edge() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmp_1_1_halfedge.html">Halfedge</a> new_edge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmp_1_1_vertex.html">Vertex</a>&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpmp_1_1_vertex.html">Vertex</a>&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocate a new edge, resize edge and halfedge properties accordingly. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmp_1_1_allocation_exception.html" title="Exception indicating failure to allocate a new resource.">AllocationException</a></td><td>in case of failure to allocate a new edge. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start</td><td>starting <a class="el" href="classpmp_1_1_vertex.html" title="this type represents a vertex (internally it is basically an index)">Vertex</a> of the new edge </td></tr>
    <tr><td class="paramname">end</td><td>end <a class="el" href="classpmp_1_1_vertex.html" title="this type represents a vertex (internally it is basically an index)">Vertex</a> of the new edge </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adf32bb2f51669546e4d6ee9968c10042" name="adf32bb2f51669546e4d6ee9968c10042"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf32bb2f51669546e4d6ee9968c10042">&#9670;&#160;</a></span>new_face()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmp_1_1_face.html">Face</a> new_face </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocate a new face, resize face properties accordingly. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmp_1_1_allocation_exception.html" title="Exception indicating failure to allocate a new resource.">AllocationException</a></td><td>in case of failure to allocate a new face. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a58cd90c6291c87ba918f4d9591ffb839" name="a58cd90c6291c87ba918f4d9591ffb839"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58cd90c6291c87ba918f4d9591ffb839">&#9670;&#160;</a></span>new_vertex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmp_1_1_vertex.html">Vertex</a> new_vertex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocate a new vertex, resize vertex properties accordingly. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmp_1_1_allocation_exception.html" title="Exception indicating failure to allocate a new resource.">AllocationException</a></td><td>in case of failure to allocate a new vertex. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6f5891098f965b93a2c9fd6927301be6" name="a6f5891098f965b93a2c9fd6927301be6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f5891098f965b93a2c9fd6927301be6">&#9670;&#160;</a></span>next_halfedge()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmp_1_1_halfedge.html">Halfedge</a> next_halfedge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmp_1_1_halfedge.html">Halfedge</a>&#160;</td>
          <td class="paramname"><em>h</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the next halfedge within the incident face </dd></dl>

</div>
</div>
<a id="a932eceb1f8fbf1ef8a55d408238d2b07" name="a932eceb1f8fbf1ef8a55d408238d2b07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a932eceb1f8fbf1ef8a55d408238d2b07">&#9670;&#160;</a></span>opposite_halfedge()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmp_1_1_halfedge.html">Halfedge</a> opposite_halfedge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmp_1_1_halfedge.html">Halfedge</a>&#160;</td>
          <td class="paramname"><em>h</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the opposite halfedge of <code>h</code> </dd></dl>

</div>
</div>
<a id="a9e02108cce3438fb23485f5309b6dd00" name="a9e02108cce3438fb23485f5309b6dd00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e02108cce3438fb23485f5309b6dd00">&#9670;&#160;</a></span>positions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="group__core.html#ga4fc38b084567aed726be776958bfcc78">Point</a> &gt; &amp; positions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>vector of point positions </dd></dl>

</div>
</div>
<a id="ab947bd972c6571ed2fff6e6d30dab257" name="ab947bd972c6571ed2fff6e6d30dab257"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab947bd972c6571ed2fff6e6d30dab257">&#9670;&#160;</a></span>prev_halfedge()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmp_1_1_halfedge.html">Halfedge</a> prev_halfedge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmp_1_1_halfedge.html">Halfedge</a>&#160;</td>
          <td class="paramname"><em>h</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the previous halfedge within the incident face </dd></dl>

</div>
</div>
<a id="a0438b9632f38f9216e99968de0091dc8" name="a0438b9632f38f9216e99968de0091dc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0438b9632f38f9216e99968de0091dc8">&#9670;&#160;</a></span>remove_edge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool remove_edge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmp_1_1_edge.html">Edge</a>&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove edge and merge its two incident faces into one. </p>
<p>This operation requires that the edge has two incident faces and that these two are not equal. </p><dl class="section see"><dt>See also</dt><dd>is_removal_ok(Edge) </dd></dl>

</div>
</div>
<a id="a50a3bf2eb0717d2315c4fb98d46ec2ef" name="a50a3bf2eb0717d2315c4fb98d46ec2ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50a3bf2eb0717d2315c4fb98d46ec2ef">&#9670;&#160;</a></span>split() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmp_1_1_halfedge.html">Halfedge</a> split </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmp_1_1_edge.html">Edge</a>&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__core.html#ga4fc38b084567aed726be776958bfcc78">Point</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Split the edge <code>e</code> by first adding point <code>p</code> to the mesh and then connecting it to the two vertices of the adjacent triangles that are opposite to edge <code>e</code>. </p>
<p>Returns the halfedge pointing to <code>p</code> that is created by splitting the existing edge <code>e</code>.</p>
<dl class="section attention"><dt>Attention</dt><dd>This function is only valid for triangle meshes. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classpmp_1_1_surface_mesh.html#a9e4a45fbb9a2a0c07a24bae805e9b2ee" title="Split the edge e by connecting vertex v it to the two vertices of the adjacent triangles that are opp...">split(Edge, Vertex)</a> </dd></dl>

</div>
</div>
<a id="a9e4a45fbb9a2a0c07a24bae805e9b2ee" name="a9e4a45fbb9a2a0c07a24bae805e9b2ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e4a45fbb9a2a0c07a24bae805e9b2ee">&#9670;&#160;</a></span>split() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmp_1_1_halfedge.html">Halfedge</a> split </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmp_1_1_edge.html">Edge</a>&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpmp_1_1_vertex.html">Vertex</a>&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Split the edge <code>e</code> by connecting vertex <code>v</code> it to the two vertices of the adjacent triangles that are opposite to edge <code>e</code>. </p>
<p>Returns the halfedge pointing to <code>v</code> that is created by splitting the existing edge <code>e</code>.</p>
<dl class="section attention"><dt>Attention</dt><dd>This function is only valid for triangle meshes. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classpmp_1_1_surface_mesh.html#a50a3bf2eb0717d2315c4fb98d46ec2ef" title="Split the edge e by first adding point p to the mesh and then connecting it to the two vertices of th...">split(Edge, const Point&amp;)</a> </dd></dl>

</div>
</div>
<a id="a93802d22c9ef77e8bd2fcf3c981713f4" name="a93802d22c9ef77e8bd2fcf3c981713f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93802d22c9ef77e8bd2fcf3c981713f4">&#9670;&#160;</a></span>split() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmp_1_1_vertex.html">Vertex</a> split </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmp_1_1_face.html">Face</a>&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__core.html#ga4fc38b084567aed726be776958bfcc78">Point</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Split the face <code>f</code> by first adding point <code>p</code> to the mesh and then inserting edges between <code>p</code> and the vertices of <code>f</code>. </p>
<p>For a triangle this is a standard one-to-three split. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classpmp_1_1_surface_mesh.html#af9080aac7bc4e23d952ccea7335d4550" title="Split the face f by inserting edges between v and the vertices of f.">split(Face, Vertex)</a> </dd></dl>

</div>
</div>
<a id="af9080aac7bc4e23d952ccea7335d4550" name="af9080aac7bc4e23d952ccea7335d4550"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9080aac7bc4e23d952ccea7335d4550">&#9670;&#160;</a></span>split() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void split </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmp_1_1_face.html">Face</a>&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpmp_1_1_vertex.html">Vertex</a>&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Split the face <code>f</code> by inserting edges between <code>v</code> and the vertices of <code>f</code>. </p>
<p>For a triangle this is a standard one-to-three split. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classpmp_1_1_surface_mesh.html#a93802d22c9ef77e8bd2fcf3c981713f4" title="Split the face f by first adding point p to the mesh and then inserting edges between p and the verti...">split(Face, const Point&amp;)</a> </dd></dl>

</div>
</div>
<a id="a662504cbe67b5f9fd40b1ffe605d0ac7" name="a662504cbe67b5f9fd40b1ffe605d0ac7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a662504cbe67b5f9fd40b1ffe605d0ac7">&#9670;&#160;</a></span>to_vertex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmp_1_1_vertex.html">Vertex</a> to_vertex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmp_1_1_halfedge.html">Halfedge</a>&#160;</td>
          <td class="paramname"><em>h</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the vertex the halfedge <code>h</code> points to </dd></dl>

</div>
</div>
<a id="aecbaa899c528570e821a1f1aad56650b" name="aecbaa899c528570e821a1f1aad56650b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecbaa899c528570e821a1f1aad56650b">&#9670;&#160;</a></span>vertex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmp_1_1_vertex.html">Vertex</a> vertex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmp_1_1_edge.html">Edge</a>&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the <code>i'th</code> vertex of edge <code>e</code>. <code>i</code> has to be 0 or 1. </dd></dl>

</div>
</div>
<a id="a555e3a8f59c76a204cb23146e30fc28c" name="a555e3a8f59c76a204cb23146e30fc28c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a555e3a8f59c76a204cb23146e30fc28c">&#9670;&#160;</a></span>vertex_properties()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; vertex_properties </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the names of all vertex properties </dd></dl>

</div>
</div>
<a id="a4465582636194110ddbce299daebeb4a" name="a4465582636194110ddbce299daebeb4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4465582636194110ddbce299daebeb4a">&#9670;&#160;</a></span>vertex_property()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmp_1_1_vertex_property.html">VertexProperty</a>&lt; T &gt; vertex_property </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>t</em> = <code>T()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>if a vertex property of type <code>T</code> with name <code>name</code> exists, it is returned. </p>
<p>otherwise this property is added (with default value <code>t</code>) </p>

</div>
</div>
<a id="a2c155f3e7e2ceabdfb7b5457e891ab9a" name="a2c155f3e7e2ceabdfb7b5457e891ab9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c155f3e7e2ceabdfb7b5457e891ab9a">&#9670;&#160;</a></span>vertices() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmp_1_1_surface_mesh_1_1_vertex_container.html">VertexContainer</a> vertices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>vertex container for C++11 range-based for-loops </dd></dl>

</div>
</div>
<a id="a5d7a2f713bc33199c572c5e86d50e379" name="a5d7a2f713bc33199c572c5e86d50e379"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d7a2f713bc33199c572c5e86d50e379">&#9670;&#160;</a></span>vertices() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmp_1_1_surface_mesh_1_1_vertex_around_face_circulator.html">VertexAroundFaceCirculator</a> vertices </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmp_1_1_face.html">Face</a>&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>circulator for vertices of face <code>f</code> </dd></dl>

</div>
</div>
<a id="a19df4baf50796afd22f7a238fb8fba47" name="a19df4baf50796afd22f7a238fb8fba47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19df4baf50796afd22f7a238fb8fba47">&#9670;&#160;</a></span>vertices() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmp_1_1_surface_mesh_1_1_vertex_around_vertex_circulator.html">VertexAroundVertexCirculator</a> vertices </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmp_1_1_vertex.html">Vertex</a>&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>circulator for vertices around vertex <code>v</code> </dd></dl>

</div>
</div>
<a id="ae74e42fa45975f08ae79f27b82d79614" name="ae74e42fa45975f08ae79f27b82d79614"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae74e42fa45975f08ae79f27b82d79614">&#9670;&#160;</a></span>vertices_begin()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmp_1_1_surface_mesh_1_1_vertex_iterator.html">VertexIterator</a> vertices_begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>start iterator for vertices </dd></dl>

</div>
</div>
<a id="aea3629fcd038ae4cf98ec4c60094da9e" name="aea3629fcd038ae4cf98ec4c60094da9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea3629fcd038ae4cf98ec4c60094da9e">&#9670;&#160;</a></span>vertices_end()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmp_1_1_surface_mesh_1_1_vertex_iterator.html">VertexIterator</a> vertices_end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>end iterator for vertices </dd></dl>

</div>
</div>
<a id="a005316b027701d5a1999209fc6a1f453" name="a005316b027701d5a1999209fc6a1f453"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a005316b027701d5a1999209fc6a1f453">&#9670;&#160;</a></span>vertices_size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t vertices_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>number of (deleted and valid) vertices in the mesh </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="nav-path" class="navpath">
  <address>
    Copyright © 2011-2025 the Polygon Mesh Processing Library developers.
  </address>
</div>
</body>
</html>